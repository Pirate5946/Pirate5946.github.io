<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pirate5946</title>
  
  <subtitle>coding world, coding life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-23T04:49:31.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Pirate5946</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java知识体系 -- JVM篇</title>
    <link href="http://yoursite.com/2020/05/23/JVM-2017-09-21-Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-JVM%E7%AF%87/"/>
    <id>http://yoursite.com/2020/05/23/JVM-2017-09-21-Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-JVM%E7%AF%87/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章</p><ul><li><a href="http://blog.csdn.net/boyupeng/article/details/47951037" target="_blank" rel="noopener">类加载机制（类加载过程和类加载器）</a></li><li><a href="http://blog.csdn.net/likika2012/article/details/45575285" target="_blank" rel="noopener">JVM加载class文件的原理</a><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><blockquote><p>类加载机制的定义</p></blockquote></li></ul><p>JVM 通过 ClassLaoder 将 主机硬盘里的 <strong>Class文件</strong>（8字节为单位的二进制流，任何编程语言通过各自的编译器都能编译成对应的Class文件） 加载到 JVM的方法区，<br>并对方法区中 <strong>Class字节码</strong>进行 校验、解析、和初始化、最终形成可以被JVM直接使用的 <strong>数据类型</strong></p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ol><li>类文件的加载     <ul><li>通过一个类的名字==获取此类的二进制字节流==（PS：不限于从文件中读取）<ul><li>从EAR包、WAR包、JAR包中获取</li><li>从网络中获取，这种场景最典型的应用就是Applet</li><li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy 中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类 的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。(<strong>运行时数据结构是什么</strong>，由具体的虚拟机自己定义) </li><li>在内存中==生成一个代表这个类的java.lang.Class对象==，作为方法区这个类的各种数据的访问入口。</li></ul></li></ul></li></ol><p>当类加载完成后，系统会给为之生成一个对象 ==（对象的实例化，还没有被栈里的指针引用）==<br><strong>defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</strong>（只要二进制字节流的内容符合Class文件规范）。==这个对象作为程序访问方法区中的这些类型数据的外部接口==</p><p>==随后进入链接阶段，链接阶段负责把类的二进制数据添加到JRE中。==</p><hr><h3 id="类的链接"><a href="#类的链接" class="headerlink" title="类的链接"></a>类的链接</h3><ol start="2"><li>Class文件的==字节流验证==：<ul><li>文件格式验证</li><li>元数据验证（语义分析，类与类的继承关系等）</li><li>字节码验证（数据流和控制流分析）</li><li>符号引用验证（对类自身以外的信息进行匹配校验）</li></ul></li><li>准备<br> 正式为类变量分配内存并设置<strong>默认初始值</strong>，这里类变量指的是被static修饰的变量。例外：如果类字段是常量 <strong>(被final修饰)</strong>，则在这里会被初始化为表达式指定的值</li><li>解析：<br>将常量池内的符号引用替换为直接引用。<br>符号引用：类似于OS中的逻辑地址；<br>直接引用：类似于OS中的物理地址，直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。     </li></ol><hr><h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><ol start="5"><li>初始化：     </li></ol><p>真正开始执行类中定义的Java程序代码；初始化用于执行Java类的构造方法。<br>初始化阶段是执行类构造器<clinit>()方法的过程。  </p><p>在以下四种情况下初始化过程会被触发执行：    </p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。<br>生成这4条指令的最常见的java代码场景是：<ul><li>使用new关键字实例化对象、</li><li>读取或设置一个类的静态字段的时候 (被final修饰、已在编译器把结果放入常量池的静态字段除外[intern()方法])，</li><li>调用类的静态方法的时候。</li></ul></li><li>使用java.lang.reflect包的方法对类进行反射调用的时候</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化</li><li>jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类</li></ul><p>举个栗子：<br>在上面<strong>准备阶段</strong> public static int value  = 12;  在准备阶段完成后 value的值为0，<br>而在<strong>初始化阶段</strong>调用了类构造器<clinit>()方法，这个阶段完成后value的值为12。</p><p>类初始化的过程是不可逆的，如果中间一步出错，则无法执行下一步</p><hr><h3 id="类加载器与双亲委派模型"><a href="#类加载器与双亲委派模型" class="headerlink" title="类加载器与双亲委派模型"></a>类加载器与双亲委派模型</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></p><ol><li><p>Bootstrap ClassLoader :<br>将存放于<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用</p></li><li><p>Extension ClassLoader :<br>将<JAVA_HOME>\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。</p></li><li><p>Application ClassLoader :<br>负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。</p></li></ol><p><img src="http://ovybbprpf.bkt.clouddn.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="类加载器双亲委派模型"><br>工作过程：<br>如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，<br>每个层次的类加载器都是如此，因此<strong>所有的加载请求都应该传送到顶层的启动类加载器中</strong>，<br>只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p>好处：</p><ol><li>安全性<br>避免用户编写的类动态替换Java的一些核心类    </li></ol><p><strong>java类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。<br>例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此<strong>Object类在程序的各种类加载器环境中都是同一个类</strong>。<br>2. 避免类的重复加载<br> JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不同的 ClassLoader加载就是不同的两个类。</p><p>相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>所有加载过的类都会缓存在内存中，<br>如果程序中尝试使用某个class时，先从缓存中查找这个类；<br>如果不存在，则读取该类对应的二进制文件并将其转换为class对象并存入缓存区。<br>这就是为什么类修改后需要重启的原因。</p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例</p><ol><li><p>从上面源码看出，调用loadClass时会先根据委派模型在父加载器中加载，如果加载失败，则会调用当前加载器的findClass来完成加载。</p></li><li><p>因此我们<strong>自定义的类加载器只需要继承ClassLoader</strong>，<strong>并覆盖findClass方法</strong>，下面是一个实际例子，在该例中我们用自定义的类加载器去加载我们事先准备好的class文件。         </p></li></ol><p><strong>ClassLoader.defineClass()方法可以把二进制流字节组成的文件转换为一个java.lang.Class</strong></p><p><a href="http://blog.csdn.net/boyupeng/article/details/47951037" target="_blank" rel="noopener">优秀文章 - 类加载分析，自定义类加载器</a></p><p><a href="http://blog.csdn.net/seu_calvin/article/details/52315125" target="_blank" rel="noopener">为什么要自定义类加载器</a></p><ul><li>对代码进行加密</li><li>从指定来源加载类</li><li>综合前两种情况</li></ul><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><ol><li>Class.forName(“包名.类名”).newInstance();   // 类加载机制</li><li>new 类名();  // 类加载的初始化阶段</li></ol><p>newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。<br>这样分步的好处是显而易见的。类的加载 和 类实例化 分开处理。<br>我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种解耦的手段。</p><p>区别：      </p><ol><li>Class下的newInstance()的使用有局限，因为它生成对象只能调用无参的构造函数；使用 new关键字生成对象没有这个限制。</li><li>newInstance( )是一个方法，而new是一个关键字；</li></ol><hr><p>参考文章：  </p><ol><li><a href="http://blog.csdn.net/boyupeng/article/details/47948243" target="_blank" rel="noopener">垃圾回收机制 &amp;&amp; 弱引用</a><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2></li></ol><hr><p>参考文章    </p><ol><li><a href="http://blog.csdn.net/java2000_wl/article/details/8009362" target="_blank" rel="noopener"> Java虚拟机学习 - 体系结构 内存模型</a><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2></li></ol><p><img src="http://ovybbprpf.bkt.clouddn.com/JVM%E7%B3%BB%E5%88%97-%E5%86%85%E5%AD%98%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png" alt="image"></p><p>JDK1.7以前 常量池是放在Java JVM中的方法区中的，许多人也叫它“永久代”     </p><p>JDK1.7中，这个常量池是移动到了java堆中去了</p><p>JDK1.8中，移除整个永久代（常量池），取而代之的是一个叫元空间（Metaspace）的区域，（使用本地内存来存储类元数据信息）</p><h3 id="内存分为哪几部分"><a href="#内存分为哪几部分" class="headerlink" title="内存分为哪几部分"></a>内存分为哪几部分</h3><p>1. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文章&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/boyupeng/article/details/47951037&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;类加载机制（类加载过程和类加载器）&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
      <category term="Java基础与提高" scheme="http://yoursite.com/categories/JVM/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Java知识体系" scheme="http://yoursite.com/tags/Java%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>封装,继承,多态</title>
    <link href="http://yoursite.com/2020/05/23/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98-2017-09-12-%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2020/05/23/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98-2017-09-12-%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/chenssy/article/details/12757911" target="_blank" rel="noopener">Java提高篇1 - 封装</a></p><h3 id="Java特性-封装"><a href="#Java特性-封装" class="headerlink" title="Java特性 - 封装"></a>Java特性 - 封装</h3><ul><li><p>隐藏类的属性和内部方法，只暴露必要的访问接口</p></li><li><p>调整类的属性或者方法时，接口方法不用改动，调整内部实现就可以</p></li><li><p>可以对成员变量的访问进行控制，（进行逻辑判断检查输入的数据是否符合要求），提高代码健壮性</p></li></ul><hr><h3 id="Java特性-继承"><a href="#Java特性-继承" class="headerlink" title="Java特性 - 继承"></a>Java特性 - 继承</h3><p>1、子类拥有父类==非private==的属性和方法。</p><p>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p><p>3、子类可以用自己的方式实现父类的方法。</p><p><strong>不支持多继承的原因</strong>：<br>==如果多个父类有共同方法，会产生调用不确定性==</p><p>this ： 代表一个本类对象的引用<br>super ： 代表一个父类空间   </p><blockquote><p>子类重写父类方法</p></blockquote><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>子类重写父类方法时，子类权限必须要大于等于父类的权限</li><li>静态只能覆盖静态，或者被静态覆盖<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4>对一个类进行子类的扩展时，子类需要保留父类的方法声明，但是要定义子类中该方法的特有内容时，使用重写操作</li></ul><h4 id="子类的实例化过程"><a href="#子类的实例化过程" class="headerlink" title="子类的实例化过程"></a>子类的实例化过程</h4><p>==子类中所有的构造函数默认都会访问父类中的空参数的构造函数==  </p><h4 id="子类实例化的时候为什么要访问父类中的构造函数"><a href="#子类实例化的时候为什么要访问父类中的构造函数" class="headerlink" title="子类实例化的时候为什么要访问父类中的构造函数"></a>子类实例化的时候为什么要访问父类中的构造函数</h4><p>因为子类继承了父类，获取到了父类中的内容，所有在使用父类内容之前，要先看父类是如何对自己内容进行初始化的，所以子类在构造对象时，必须访问父类中的构造函数</p><p>如果父类中没有定义空参构造函数，那么子类==必须在子类构造函数第一行，显式写super语句==，如果使用了this调用本类的构造函数，那么就没有super了，子类中的其他构造函数会访问父类的构造函数</p><blockquote><p>讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型     </p></blockquote><ul><li>构造器    </li></ul><p>通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。<br>对于构造器而言，它只能够被调用，而不能被继承。    </p><p>==对于继承来说，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器==，而且必须是在子类构造器中做的第一件事(第一行代码)。       </p><p>调用父类的构造方法我们使用super()即可。</p><ul><li><p>protected关键字<br>protected修饰的类，只可以被==子类==以及与它位于==同一个包的类==访问到</p></li><li><p>向上转型<br>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。<br>由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。</p></li></ul><h4 id="谨慎使用继承"><a href="#谨慎使用继承" class="headerlink" title="谨慎使用继承"></a>谨慎使用继承</h4><p>继承存在如下缺陷：<br>1、父类变，子类就必须变。   </p><p>2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。    </p><p>3、继承是一种强耦合关系。</p><p>问一问自己是否需要从子类向父类进行向上转型。==如果必须向上转型，则继承是必要的==，但是如果不需要，则应当好好考虑自己是否需要继承。         </p><hr><h3 id="Java特性-多态"><a href="#Java特性-多态" class="headerlink" title="Java特性 - 多态"></a>Java特性 - 多态</h3><h3 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a><a href="http://hxraid.iteye.com/blog/428891" target="_blank" rel="noopener">多态原理</a></h3><p>父类或者接口的引用指向其子类的对象  </p><p>只有在运行的时候才会知道引用变量所指向的具体实例对象。</p><p><strong>多态的好处</strong>    </p><ul><li>提高了代码的扩展性<br>原来代码传入一个接口或者类<br>扩展时，传入一个子类，原来的代码不用变，==由子类重写原来的方法，原来的引用会指向子类重写后的方法==<br>不用重新定义一个方法，传入新的对象</li></ul><p>由于继承了父类的子类对象可以==向上转型==为父类对象，所以可以定义==一个父类对象的引用指向子类对象==  </p><p>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而==对于子类中存在而父类中不存在的方法，该引用是不能使用的==，尽管是重载该方法。<br>若==子类重写==了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</p><h3 id="多态时成员的特点"><a href="#多态时成员的特点" class="headerlink" title="多态时成员的特点"></a>多态时成员的特点</h3><p>Animal cat = new Cat;</p><ol><li>成员变量<br>编译和运行都参考等号的左边</li><li>成员函数（非静态）<br>编译看左边，运行看右边  </li><li>静态方法<br>编译和运行都看左边，==静态方法和类绑定，类名直接调用==<h4 id="覆盖重写只发生在方法上，父类的属性无法被覆盖"><a href="#覆盖重写只发生在方法上，父类的属性无法被覆盖" class="headerlink" title="覆盖重写只发生在方法上，父类的属性无法被覆盖"></a>覆盖重写只发生在方法上，父类的属性无法被覆盖</h4></li></ol><p><strong>为了在父类引用中使用子类的特有方法，可以将父类对象==向下转型==，转换成对应的子类引用</strong></p><h3 id="判断对象具体类型的关键字"><a href="#判断对象具体类型的关键字" class="headerlink" title="判断对象具体类型的关键字"></a>判断对象具体类型的关键字</h3><p><strong>==instanceof==</strong>，通常用于向下转型前进行健壮性的判断</p><blockquote><p>多态的三个必要条件 </p></blockquote><ul><li>继承、实现：在多态中必须存在有继承关系的子类和父类或者实现类接口的类。<ul><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul></li></ul><blockquote><p>多态的实现形式 </p></blockquote><ul><li>继承<br>对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。<br>==如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法==，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。<br>这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。</li><li>接口<br>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。<br>所以它相对于继承来说有更好的灵活性。</li></ul><p><a href="http://blog.csdn.net/chenssy/article/details/12786385" target="_blank" rel="noopener">根据继承链中方法调用的优先级来确认方法，该优先级为：  </a><br>this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/12757911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java提高篇1 - 封装&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Java特性-封装&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java基础与提高" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98/"/>
    
    
      <category term="Java基础特性" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>动态代理原理分析</title>
    <link href="http://yoursite.com/2020/05/23/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98-2017-08-30-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/05/23/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98-2017-08-30-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理类的字节码是在程序运行期间由JVM根据反射等机制动态的生成，所以==不存在代理类的class文件==。代理类和委托类的关系是在程序运行时确定。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java 动态代理机制分析及扩展，第 1 部分</a>  </p><p><a href="http://blog.csdn.net/mhmyqn/article/details/48474815" target="_blank" rel="noopener">动态代理分析2</a></p><p><a href="http://www.cnblogs.com/MOBIN/p/5597215.html" target="_blank" rel="noopener">动态代理分析</a></p><h3 id="相关的类和接口"><a href="#相关的类和接口" class="headerlink" title="相关的类和接口"></a>相关的类和接口</h3><ul><li><p>java.lang.reflect.Proxy：<br>这是 Java 动态代理机制的主类，它提供了一组静态方法来==为一组接口动态地生成代理类及其对象==</p><ul><li><p>// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器<br>static InvocationHandler getInvocationHandler(Object proxy) </p></li><li><p>// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器==生成动态代理类实例==<br>static Object newProxyInstance(ClassLoader loader, Class[] interfaces,<br>InvocationHandler h)</p></li></ul></li><li><p>java.lang.reflect.InvocationHandler：<br>这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p><ul><li>// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象<br>// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行<br>Object invoke(Object proxy, Method method, Object[] args)</li></ul></li></ul><p>==动态代理类==与普通类的唯一区别就是其字节码是由 ==JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中==。<br>通过类装载器来进行装载才能使用</p><h3 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤"></a>具体实现步骤</h3><ol><li><p>通过实现 InvocationHandler 接口==创建自己的调用处理器==；  </p></li><li><p>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来==创建动态代理类==；</p></li><li><p>通过反射机制==获得动态代理类的构造函数==，其唯一参数类型是调用处理器接口类型；</p></li><li><p>通过构造函数==创建动态代理类实例，==构造时调用处理器对象作为参数被传入====</p></li></ol><p>实际使用过程更加简单，因为 Proxy 的静态方法 newProxyInstance 已经为我们封装了步骤 2 到步骤 4 的过程，所以简化后的过程如下    </p><ol><li><p>// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发<br>InvocationHandler handler = new InvocationHandlerImpl(..); </p></li><li><p>// 通过 Proxy 直接创建动态代理类实例<br>Interface proxy = (Interface)Proxy.newProxyInstance( classLoader,<br>new Class[] { Interface.class }, handler ); </p></li></ol><h3 id="Java-动态代理机制的一些特点。"><a href="#Java-动态代理机制的一些特点。" class="headerlink" title="Java 动态代理机制的一些特点。"></a>Java 动态代理机制的一些特点。</h3><ul><li>包：<br>如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空）<br>如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包（假设代理了 com.ibm.developerworks 包中的某非 public 接口 A，那么新生成的代理类所在的包就是 com.ibm.developerworks），<br>这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；    </li><li>类修饰符：<br>==该代理类具有 final 和 public 修饰符==，意味着它可以被所有的类访问，但是不能被再度继承；</li><li>类名：<br>格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，<br>值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，<br>这样可以节省不必要的代码重复生成，提高了代理类的创建效率。</li><li>4）类继承关系：<br>该类的继承了Proxy类、实现了一组接口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h3&gt;&lt;p&gt;动态代理类的字节码是在程序运行期间由JVM根据反射等机制动态的生成，所以==不存在代理类的class文件==。代理类和委托类
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java基础与提高" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>princple-2018-02-06-TODO</title>
    <link href="http://yoursite.com/2020/05/23/princple-2018-02-06-TODO/"/>
    <id>http://yoursite.com/2020/05/23/princple-2018-02-06-TODO/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: Todo List - 工作、学习<br>categories:</p><ul><li>201810</li><li>TODO</li></ul><p>tags:</p><ul><li>待办事项</li></ul><hr><ol><li>清晰的里程碑<ol start="2"><li>最大的困难，次大的困难</li><li>诊断问题，找到问题的核心</li><li>解决困难的办法，方案</li><li>坚决地执行</li></ol></li></ol><h2 id="Tode-List-of-Work"><a href="#Tode-List-of-Work" class="headerlink" title="Tode List of Work"></a>Tode List of Work</h2><ul><li>计算机操作系统 第二章-进程管理</li><li>python视频 H:\Python3入门与进阶<ul><li><a href="">python知识点</a></li></ul></li><li>高等数学 同济版 上册</li><li>LeetCode刷题</li><li>排序算法代码整理  </li><li>递归、分治策略、动态规划以及贪心算法之间的关系</li><li><a href="http://www.bilibili.com/video/av17952743?share_medium=android&amp;share_source=copy_link&amp;bbid=87E1A2EB-DC6F-4726-A9A5-51D5A927762310277infoc&amp;ts=1517586081164" target="_blank" rel="noopener">http://www.bilibili.com/video/av17952743?share_medium=android&amp;share_source=copy_link&amp;bbid=87E1A2EB-DC6F-4726-A9A5-51D5A927762310277infoc&amp;ts=1517586081164</a></li></ul><hr><ul><li>算法题目整理      <ul><li>二叉树的</li></ul></li><li>阿里大数据 学习文档</li></ul><hr><ul><li><p><a href="http://ylxt.dhcc.com.cn/ylxt/uimain.aspx#" target="_blank" rel="noopener">医疗协同 日报</a></p></li><li><p><a href="http://xmgl.donghuajinyun.com/access.do" target="_blank" rel="noopener">项目周报系统 - 用IE打开</a></p></li><li><p><a href="http://mail.dhcc.com.cn/user/?q=login" target="_blank" rel="noopener">周报邮件</a>    F:\报表_北京中关村银行报表系统\每周周报</p></li><li><p>2018规划、月计划周安排整理</p></li><li><p>随时记 电影、电视剧、音乐、综艺</p></li></ul><hr><h2 id="Todo-List-of-Study"><a href="#Todo-List-of-Study" class="headerlink" title="Todo List of Study"></a>Todo List of Study</h2><ul><li>leetcode日记、阅读日记 - <a href="https://leetcode.com/tag/backtracking/" target="_blank" rel="noopener">Backtracking 专题</a></li><li><a href="http://open.163.com/special/Khan/precalculus.html" target="_blank" rel="noopener">可汗学院公开课：微积分预备</a></li><li><a href="http://write.blog.csdn.net/postlist" target="_blank" rel="noopener">CSDN 博客 -  赚积分，下载408真题</a></li><li>单词打卡、听力、阅读</li><li>leetcode、PAT 刷题打卡</li></ul><h3 id="宏观规划"><a href="#宏观规划" class="headerlink" title="宏观规划"></a>宏观规划</h3><ul><li>==制定 学习时间表== </li><li>整理近五年各科真题<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3></li><li>检索和散列类 p410</li><li>leetcode 解题思路 1-34<br><a href="http://www.cnblogs.com/zmyvszk/archive/2016/04.html" target="_blank" rel="noopener">http://www.cnblogs.com/zmyvszk/archive/2016/04.html</a></li></ul><hr><h2 id="ToDo-List"><a href="#ToDo-List" class="headerlink" title="ToDo List"></a>ToDo List</h2><ul><li>确定一个Java开源项目、<ul><li>相关主题 netty源码结构分析 </li><li>分布式、数据库</li><li>微服务</li><li>==数据库索引 使用的算法==</li></ul></li><li>数据结构 <ul><li>数据结构与Java集合框架 p513<br>附录 C  Collection 接口与 ==集合框架体系==  </li><li>树 –》 Treemap       </li></ul></li><li>Java编程思想 回顾总结、笔记（大纲性笔记）<ul><li>集合框架、数据结构、LeetCode 刷题（==经常练习、常用方法笔记==）</li><li>跟完 邓俊辉数据结构、笔记、算法刷题 </li><li>数据结构和Java集合框架</li></ul></li><li>JUC脑图  </li></ul><hr><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><input disabled="" type="checkbox"> 音标（英式发音、美式发音） – 时常回顾缤纷英语的收藏课程<ul><li>重读的位置 ： 区分单词的词性  ，名词、动词、形容词 </li><li>发音长短：长元音、短元音</li><li>辅音与元音的连读： 上一个单词的结尾辅音+下一个单词的元音开头</li><li>清辅音结尾与浊辅音结尾 </li></ul></li><li><input checked="" disabled="" type="checkbox"> 跟完逻辑英语、B站英语收藏夹、笔记、日常练习<ul><li>词根词缀  b站收藏夹</li><li>扇贝阅读、阅读真题训练</li></ul></li><li><input disabled="" type="checkbox"> 每日一篇文章、背诵句子、整理单词至少每周回顾，最好每1-3天回顾一次<ul><li>缤纷英语</li><li>有道词典</li><li>扇贝阅读</li></ul></li></ul><hr><h2 id="数学（微积分）"><a href="#数学（微积分）" class="headerlink" title="数学（微积分）"></a>数学（微积分）</h2><ul><li>学习资料整理  </li><li>做题、笔记整理回顾</li></ul><hr><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><ul><li>整理答题思路、背诵 固定句式</li></ul><hr><ul><li>设计模式、 第一遍笔记</li><li><input disabled="" type="checkbox"> 高级Bash编程指南  <ul><li>中级 - 第九章（<strong>参考书式的笔记</strong>）</li><li>第十章 <strong>循环和分支</strong></li></ul></li></ul><p><img src="H:%5C%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%5C%E5%9C%A8%E7%B6%AB%E8%85%A6%E5%9C%96.png" alt="TodoList"></p><hr><p>数学公式</p><h2 id="Mathmatical-formula"><a href="#Mathmatical-formula" class="headerlink" title="Mathmatical formula"></a>Mathmatical formula</h2><p><code>$y = x^2$</code></p><p>Inline math: <code>$\dfrac{\tfrac{1}{2}[1-(\tfrac{1}{2})^n] }{1-\tfrac{1}{2} } = s_n$</code></p><p>Math block:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\oint_C x^3\, dx + 4y^2\, dy</span><br><span class="line"></span><br><span class="line">2 &#x3D; \left(\frac&#123;\left(3-x\right) \times 2&#125;&#123;3-x&#125;\right)</span><br><span class="line"></span><br><span class="line">\sum_&#123;m&#x3D;1&#125;^\infty\sum_&#123;n&#x3D;1&#125;^\infty\frac&#123;m^2\,n&#125;&#123;3^m\left(m\,3^n+n\,3^m\right)&#125;</span><br><span class="line"></span><br><span class="line">\phi_n(\kappa) &#x3D; </span><br><span class="line">\frac&#123;1&#125;&#123;4\pi^2&#125; \int_0^\infty</span><br><span class="line">\frac&#123;\sin(\kappa R)&#125;&#123;\kappa R&#125;</span><br><span class="line">\frac&#123;\partial&#125;&#123;\partial R&#125;</span><br><span class="line">\left[R^2\frac&#123;\partial D_n(R)&#125;&#123;\partial R&#125;\right]\,dR</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: Todo List - 工作、学习&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;201810&lt;/li&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;待办事项&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试整理</title>
    <link href="http://yoursite.com/2020/05/23/interview-10-8-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/23/interview-10-8-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫刘涛，2015年毕业后主要从事ETL、报表开发、图表可视化展现相关的工作，<br>参与了湖南农村信用社的 财务报表系统后期的一些开发、维护工作</p><p>2016年底作为4人开发小组的组长，主导了北京中关村银行 企业报表系统的 部署开发上线全流程，<br>从前期项目环境搭建，需求讨论，到项目开发、流程调试，<br>上线前项目文档验收 自己都参与了其中</p><p>2018年 参与了一个CRM项目，<br>作为PAAS平台的元数据服务小组成员，主要负责元数据服务的原有功能维护 和<br>新业务功能的扩展，包括对公司其他业务线和公司的合作伙伴提供rest接口，</p><p>另外也有配合中间件小组 对元数据服务进行一些技术栈升级，<br>比如替换ID生成器，替换消息队列（kestrel转rabbit MQ）</p><p>2019年全年参与了一个机票代理平台的4.0版本迭代，项目于2020年元旦成功上线<br>自己作为项目核心开发成员，主要负责订单服务，政策服务，基础数据服务的后端功能开发<br>和部分前台页面开发，</p><p>对于微服务环境部署、服务拆分工作也有涉及</p><p>希望接下来继续从事Java服务端开发的工作</p><h2 id="项目中遇到的难点"><a href="#项目中遇到的难点" class="headerlink" title="项目中遇到的难点"></a>项目中遇到的难点</h2><h4 id="1-多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖-前面的修改），post请求-需要保证幂等性，同时记录数据变动日志"><a href="#1-多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖-前面的修改），post请求-需要保证幂等性，同时记录数据变动日志" class="headerlink" title="1. 多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖 前面的修改），post请求 需要保证幂等性，同时记录数据变动日志"></a>1. 多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖 前面的修改），post请求 需要保证幂等性，同时记录数据变动日志</h4><ol><li>拦截修改前的查询请求，根据请求生成页面版本号，在redis中缓存版本号和实体信息           </li><li>拦截修改请求，比对版本号，通过后比较实体修改前后的信息，记录操作日志</li><li>通过消息队列 解耦日志服务的后续操作 （新旧实体比较 和入库）</li></ol><h4 id="2-在一个服务中配置两个数据源"><a href="#2-在一个服务中配置两个数据源" class="headerlink" title="2. 在一个服务中配置两个数据源"></a>2. 在一个服务中配置两个数据源</h4><ol><li><p>AOP拦截指定请求，通过ThreadLocal 设置当前线程数据源</p></li><li><p>继承 AbstractRoutingDataSource 重写 determineCurrentLookupKey 方法 获取当前线程数据源 </p></li></ol><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0 基础"></a>0 基础</h2><h3 id="1、java的object方法有哪些"><a href="#1、java的object方法有哪些" class="headerlink" title="1、java的object方法有哪些"></a>1、java的object方法有哪些</h3><ul><li>hashcode、equals</li><li>getClass</li><li>toString</li><li>notify、notifyAll</li><li>wait</li><li>clone</li><li>finalize</li></ul><h3 id="2-哪些场景下，子类需要重写-equals-方法和-hashCode-方法？"><a href="#2-哪些场景下，子类需要重写-equals-方法和-hashCode-方法？" class="headerlink" title="2. 哪些场景下，子类需要重写 equals 方法和 hashCode 方法？"></a>2. 哪些场景下，子类需要重写 equals 方法和 hashCode 方法？</h3><p>Object的equals只比较了对象的引用地址，重写equals()是为了实现自己的区分逻辑，</p><p>==如果重写的equals()方法确定了两个对象相等，则这两个对象的hashCode必须返回相同的值==<br>，Object的hashCode是一个native本地方法，所以必须重写    </p><p>重写hashCode()是为了提高hash tables的使用效率，<br>如果equals()方法确定了两个对象不相等，这个两个对象的hashCode还是有可能相等的。<br>但是不同的对象应该有着不同的hashCode，这样可以提高hash tables的使用效率。</p><p>对于equals不相同而hashCode相同的元素集合，在哈希表中会以链表或者红黑树的形式储存</p><h3 id="3-列表中学生按照年龄排序"><a href="#3-列表中学生按照年龄排序" class="headerlink" title="3. 列表中学生按照年龄排序"></a>3. 列表中学生按照年龄排序</h3><p>重写compareTo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 升序 </span></span><br><span class="line">       <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">       <span class="comment">// 降序</span></span><br><span class="line">       <span class="comment">// return o2.getAge().compareTo(o1.getAge());</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="static-关键字使用场景，作用"><a href="#static-关键字使用场景，作用" class="headerlink" title="static 关键字使用场景，作用"></a>static 关键字使用场景，作用</h3><p>只存在一份引用，放在方法区，所有线程共享</p><hr><h2 id="1-Java-集合"><a href="#1-Java-集合" class="headerlink" title="1 Java 集合"></a>1 Java 集合</h2><h3 id="1-1-List"><a href="#1-1-List" class="headerlink" title="1.1 List"></a>1.1 List</h3><p>支持按索引访问，存入和取出顺序不变，元素可重复，可以保存null值   </p><h4 id="ArrayList-底层数据结构"><a href="#ArrayList-底层数据结构" class="headerlink" title="ArrayList 底层数据结构"></a>ArrayList 底层数据结构</h4><p>Object数组，</p><h4 id="add-方法逻辑"><a href="#add-方法逻辑" class="headerlink" title="add 方法逻辑"></a>add 方法逻辑</h4><p>1、 检查是否需要扩容<br>新的长度不长于 MAX_ARRAY_SIZE 时，增长为原长度的1.5倍，否则赋值为 MAX_ARRAY_SIZE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line"></span><br><span class="line">elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure><p>2、 在末尾添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[size++] = e;</span><br></pre></td></tr></table></figure><h4 id="for-foreach-循环删除list中-满足条件的对象Java-有没有问题？"><a href="#for-foreach-循环删除list中-满足条件的对象Java-有没有问题？" class="headerlink" title="for/foreach 循环删除list中 满足条件的对象Java 有没有问题？"></a>for/foreach 循环删除list中 满足条件的对象Java 有没有问题？</h4><p>有问题，快速失败机制，会抛出异常 <a href="https://my.oschina.net/hosee/blog/612718" target="_blank" rel="noopener">ConcurrentModificationException的原因以及解决措施</a></p><p>单线程解决方案：使用 迭代器的remove方法</p><p>多线程 两种解决方案：     </p><ol><li><p>在使用iterator迭代的时候使用synchronized或者Lock进行同步；（一个个迭代就和单线程一样了）</p></li><li><p>使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</p></li></ol><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>双向列表，增删快</p><h5 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><p>数据结构不同，使用场景不同</p><h3 id="在jvm层面，数组和链表有什么区别"><a href="#在jvm层面，数组和链表有什么区别" class="headerlink" title="在jvm层面，数组和链表有什么区别"></a>在jvm层面，数组和链表有什么区别</h3><p>不太清除</p><h3 id="HashSet-、"><a href="#HashSet-、" class="headerlink" title="HashSet 、"></a>HashSet 、</h3><p>内部持有 HashMap引用， key 可以为 null, 不能重复</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="hashMap的实现原理，链表是头插法还是尾插法"><a href="#hashMap的实现原理，链表是头插法还是尾插法" class="headerlink" title="hashMap的实现原理，链表是头插法还是尾插法"></a>hashMap的实现原理，链表是头插法还是尾插法</h3><p>1.8 之前是头插法、1.8是尾插法</p><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>数组 + 链表 （长度超过 8 转换成红黑树）</p><h4 id="put-方法流程"><a href="#put-方法流程" class="headerlink" title="put 方法流程"></a>put 方法流程</h4><p>1、 初始化第一次调用 put，<br>根据初始化给的初始容量（会向上调整为2的n次幂），初始化 hash表（Node&lt;K,V&gt;[] table）</p><p>2、 根据 key的 hash值取模，获取key在 hash表（Node数组）中的存放位置，<br>取模方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>如果当前索引位置没有值，在当前位置初始化 Node     </p><p>如果当前索引位置有值（hash冲突），     </p><ul><li>如果是重复的key，用新值替换旧值，返回旧值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure></li><li>遍历查看当前节点的下一节点，直到找到重复的key，用新值替换旧值，返回旧值；<br>或者找到null节点，在当前位置初始化 Node，<br>如果链表的长度 &gt;= 8 并且hash表长度大于64，将当前列表转换成红黑树，否则reHash()     </li></ul><p>3、 modCount 记录修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>4、 当前 Node数量自增1 ，与当前阈值比较，判断是否需要扩容</p><h4 id="jdk8怎么优化hashmap扩容导致的死循环问题"><a href="#jdk8怎么优化hashmap扩容导致的死循环问题" class="headerlink" title="jdk8怎么优化hashmap扩容导致的死循环问题"></a>jdk8怎么优化hashmap扩容导致的死循环问题</h4><p>JDK7 线程扩容时的搬运结点操作 为了提高效率采用的头插法 导致线程之间 看到了错误的next指向，导致成环，       </p><p>JDK8采用尾插法（尾插法一是用于避免死循环，二是根据槽中个数判断是否需要树化）修复了此问题，但是由于是线程不安全的，还会有别的并发问题发生</p><h4 id="HashMap-和-HashTable-区别？"><a href="#HashMap-和-HashTable-区别？" class="headerlink" title="HashMap 和 HashTable 区别？"></a>HashMap 和 HashTable 区别？</h4><h5 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h5><p>HashTable : 数组 + 链表</p><p>HashMap ： 数组 + 链表 （长度超过 8 转换成红黑树）</p><p>Hashtable中，key和value都不允许出现null值。        </p><p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null，<br>在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用 containsKey()方法来判断。</p><h5 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h5><p>HashTable : 线程安全 ， Synchronized 修饰方法，当前实例被锁住，只能串行调用其他方法</p><p>HashMap ： 线程不安全</p><h3 id="为啥会线程不安全？-如何才能得到一个线程安全的HashMap？"><a href="#为啥会线程不安全？-如何才能得到一个线程安全的HashMap？" class="headerlink" title="为啥会线程不安全？ 如何才能得到一个线程安全的HashMap？"></a>为啥会线程不安全？ 如何才能得到一个线程安全的HashMap？</h3><p>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p><p>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p><p>put/get方法都没有加同步锁，多线程情况最容易出现的就是：<br>无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</p><p>使用 ConcurrentHashMap、 或者 Collections.synchronizedMap()</p><h3 id="在数据结构上，栈和队列有什么区别"><a href="#在数据结构上，栈和队列有什么区别" class="headerlink" title="在数据结构上，栈和队列有什么区别"></a>在数据结构上，栈和队列有什么区别</h3><p>队列是先进先出，新来的成员总是加入队尾</p><p>栈是先进后出，继承了Vector，线程安全，栈只能从顶部取数据</p><hr><h2 id="select-epoll-poll的区别"><a href="#select-epoll-poll的区别" class="headerlink" title="select epoll,poll的区别"></a>select epoll,poll的区别</h2><p>select，poll，epoll都是IO多路复用的机制，</p><p>IO多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>不停的调用poll,直到有需要的消息为止，最大连接数 1024</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>没有连接上限</p><p>select, poll是为了解決同时大量IO的情況（尤其网络服务器），但是随着连接数越多，性能越差</p><p>epoll是select和poll的改进方案，在 linux 上可以取代 select 和 poll，可以处理大量连接的性能问题</p><h2 id="2-Java并发相关"><a href="#2-Java并发相关" class="headerlink" title="2 Java并发相关"></a>2 Java并发相关</h2><p>定义： 多个线程读写 可变的共享资源 时，跟单个线程操作结果一致</p><h3 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h3><ol><li>wait可以指定时间，也可以不指定；而sleep必须指定时间。</li><li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。</li><li>wait必须放在同步块或同步方法中，而sleep可以在任意位置</li></ol><h3 id="2-1-原理篇"><a href="#2-1-原理篇" class="headerlink" title="2.1 原理篇"></a>2.1 原理篇</h3><h4 id="比较一下-volatile-和-Synchronized"><a href="#比较一下-volatile-和-Synchronized" class="headerlink" title="比较一下 volatile 和 Synchronized"></a>比较一下 volatile 和 Synchronized</h4><p>volatile 修饰变量，可以保证 线程之间共享资源 的 可见性、有序性</p><p>Synchronized 可以修改代码块，方法，类 ；可以保证 被它修饰的方法或者代码块在任意时刻只能有一个线程执行</p><h4 id="volatile是什么，实现原理，可以实现原子性吗-线程安全吗，通过什么机制实现锁？"><a href="#volatile是什么，实现原理，可以实现原子性吗-线程安全吗，通过什么机制实现锁？" class="headerlink" title="volatile是什么，实现原理，可以实现原子性吗 ,线程安全吗，通过什么机制实现锁？"></a>volatile是什么，实现原理，可以实现原子性吗 ,线程安全吗，通过什么机制实现锁？</h4><p>volatile是通过编译器在生成字节码时，在指令序列中添加“内存屏障”来禁止指令重排序</p><p>在Java多线程情况下，volatile修饰的变量可以保证线程可见性且提供了一定的有序性，不能保证原子性，</p><p>不能保证线程安全，比如 i++</p><p>通过CAS机制实现线程安全，在Java中Unsafe对CAS进行了封装</p><h4 id="synchronized-是公平锁吗，"><a href="#synchronized-是公平锁吗，" class="headerlink" title="synchronized 是公平锁吗，"></a>synchronized 是公平锁吗，</h4><p>非公平锁， synchronized 获取不到锁的时候，会自动加入队列，等待线程释放锁后所有等待的线程同时去竞争</p><p>可重入</p><p>悲观锁</p><h4 id="实现锁的原理，获取对象的monitor-属于对象什么信息"><a href="#实现锁的原理，获取对象的monitor-属于对象什么信息" class="headerlink" title="实现锁的原理，获取对象的monitor 属于对象什么信息"></a>实现锁的原理，获取对象的monitor 属于对象什么信息</h4><p>同步代码块是使用 monitorenter 和 monitorexit 指令实现的</p><p>synchronized方法，在Class文件的方法表中将该方法的accessflags字段中的synchronized标志位置1</p><p>Java的锁都是基于对象的，对象的“锁”的信息是存放在对象头的Mark Word</p><p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“</p><p>当对象状态为偏向锁时，Mark Word存储的是偏向的线程ID；<br>当状态为轻量级锁时，Mark Word存储的是指向线程栈中Lock Record的指针；<br>当状态为重量级锁时，Mark Word为指向堆中的monitor对象的指针</p><h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起（就是不让前来获取该锁（已被占用）的线程立即阻塞），看持有锁的线程是否会很快释放锁。</p><p>怎么等待呢？</p><p>执行一段无意义的循环即可（自旋）</p><p>避免CPU从用户态转为核心态，频繁的阻塞和唤醒</p><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁，线程如果自旋成功了，那么下次自旋的次数会更加多</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-怎么判断一个对象可以被回收"><a href="#1-怎么判断一个对象可以被回收" class="headerlink" title="1. 怎么判断一个对象可以被回收"></a>1. 怎么判断一个对象可以被回收</h3><p>可达性分析 ： 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链时，则认为此对象可以被回收</p><h3 id="2-哪些对象可以作为GC-Root"><a href="#2-哪些对象可以作为GC-Root" class="headerlink" title="2. 哪些对象可以作为GC Root"></a>2. 哪些对象可以作为GC Root</h3><p>方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,</p><p>a.虚拟机栈(栈桢中的本地变量表)中的引用的对象<br>b.方法区中的类静态属性引用的对象<br>c.方法区中的常量引用的对象<br>d.本地方法栈中JNI的引用的对象       </p><h3 id="3-垃圾回收器，G1有什么优势"><a href="#3-垃圾回收器，G1有什么优势" class="headerlink" title="3. 垃圾回收器，G1有什么优势"></a>3. 垃圾回收器，G1有什么优势</h3><p>G1的设计原则就是简单可行的性能调优，</p><p>主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，尽可能的满足垃圾回收时的暂停时间</p><p>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念</p><p>G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</p><h3 id="4-jvm启动进程配置哪些参数"><a href="#4-jvm启动进程配置哪些参数" class="headerlink" title="4. jvm启动进程配置哪些参数"></a>4. jvm启动进程配置哪些参数</h3><p> nohup java -server -Duser.timezone=GMT+08 -Xmx1g -Xms1g<br> -XX:NewRatio=4 -XX:SurvivorRatio=8<br> -XX:PermSize=64m -XX:MaxPermSize=128m -Xss512k<br> -XX:ThreadStackSize=128k -XX:MaxDirectMemorySize=256m<br> -XX:-ReduceInitialCardMarks -XX:+PrintGCDetails<br> -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/LOGS/applogs/jvm-log/web-gc.log<br> -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled<br> -XX:ParallelCMSThreads=4 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection<br> -XX:CMSInitiatingOccupancyFraction=50 -XX:CMSFullGCsBeforeCompaction=2 -XX:+UseCompressedOops<br> -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/LOGS/applogs/jvm-dump/web_heapDump.hprof<br> -Dcom.sun.management.jmxremote=true -Djava.rmi.server.hostname=192.168.1.221<br> -Dcom.sun.management.jmxremote.port=28081 -Dcom.sun.management.jmxremote.ssl=false<br> -Dcom.sun.management.jmxremote.authenticate=false -XX:+UnlockCommercialFeatures -XX:+FlightRecorder<br> -jar bs4-web-0.0.1-SNAPSHOT.jar &gt;&gt;/LOGS/applogs/bs4-web.log 2&gt;&amp;1 &amp;</p><h3 id="5-你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置"><a href="#5-你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置" class="headerlink" title="5. 你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置"></a>5. 你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置</h3><p>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆内存的1/5</p><p>1.追求响应时间优先</p><p>这种需求下，新生代尽可能设置大一些，因为新生代比较大，发生垃圾回收的频率会比较低，响应时间快速。</p><p>老年代空间不足发生Full GC</p><h3 id="6-堆内存4G，老年代分2-5个G-gc时间是多长"><a href="#6-堆内存4G，老年代分2-5个G-gc时间是多长" class="headerlink" title="6. 堆内存4G，老年代分2.5个G,gc时间是多长"></a>6. 堆内存4G，老年代分2.5个G,gc时间是多长</h3><p>不知道</p><h3 id="jvm一次完整的GC流程"><a href="#jvm一次完整的GC流程" class="headerlink" title="jvm一次完整的GC流程"></a>jvm一次完整的GC流程</h3><p>当 Eden 区没有足够空间时，会发起一次 Minor GC；清理不可达的对象</p><p>存活的对象，年龄+1，一定次数后进入老年代，老年代空间不够时，进行full gc，Full GC 尽量避免</p><h3 id="栈内存溢出的情形（StackOverflowError-，如何解决"><a href="#栈内存溢出的情形（StackOverflowError-，如何解决" class="headerlink" title="栈内存溢出的情形（StackOverflowError)，如何解决"></a>栈内存溢出的情形（StackOverflowError)，如何解决</h3><p>1、递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p><p>2、方法内声明了海量的局部变量，局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。</p><p>解决方案：</p><ol><li><p>修复引发无限递归调用的异常代码,        </p></li><li><p>通过 JVM 启动参数 -Xss 增加线程栈内存空间， 某些正常使用场景需要执行大量方法或包含大量局部变量，这时可以适当地提高线程栈空间限制</p></li></ol><h3 id="线上oom怎么排查"><a href="#线上oom怎么排查" class="headerlink" title="线上oom怎么排查"></a>线上oom怎么排查</h3><p>查看日志、分析dump文件，查看占用内存较多的对象</p><ol><li><p>ps -aux|grep java 当服务重新部署后，可以找出当前Java进程的PID</p></li><li><p>jstat -gcutil pid interval 用于查看当前GC的状态,它对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控</p></li><li><p>jmap -histo:live pid 可用统计存活对象的分布情况，从高到低查看占据内存最多的对象。上图</p></li><li><p>分析dump文件</p></li></ol><hr><h3 id="2-2-JDK-工具篇"><a href="#2-2-JDK-工具篇" class="headerlink" title="2.2 JDK 工具篇"></a>2.2 JDK 工具篇</h3><h4 id="2-2-0-线程池"><a href="#2-2-0-线程池" class="headerlink" title="2.2.0 线程池"></a><a href="http://concurrent.redspider.group/article/03/12.html" target="_blank" rel="noopener">2.2.0 线程池</a></h4><p>线程池顶层接口是Executor接口，ThreadPoolExecutor 是这个接口的实现类</p><h5 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h5><p>使用线程池主要有以下三个原因：</p><ul><li>控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li><li>创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。</li><li>可以对线程做统一管理 (传入 ThreadFactory ，设置线程池名称 、线程优先级、是否为守护线程)</li></ul><p>ThreadPoolExecutor在创建线程时，会将线程封装成工作线程worker,并放入工作线程组中，<br>然后这个worker反复从阻塞队列中拿任务去执行。</p><h5 id="线程池构造函数的参数，默认值"><a href="#线程池构造函数的参数，默认值" class="headerlink" title="线程池构造函数的参数，默认值"></a>线程池构造函数的参数，默认值</h5><p>涉及到5~7个参数，必须的5个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int corePoolSize：该线程池中核心线程数最大值</span><br><span class="line"></span><br><span class="line">    核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</span><br><span class="line"></span><br><span class="line">int maximumPoolSize：该线程池中线程总数最大值 。</span><br><span class="line"></span><br><span class="line">    该值等于核心线程数量 + 非核心线程数量。</span><br><span class="line"></span><br><span class="line">long keepAliveTime：非核心线程闲置超时时长。</span><br><span class="line"></span><br><span class="line">    非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</span><br><span class="line"></span><br><span class="line">TimeUnit unit：keepAliveTime的单位。</span><br><span class="line"></span><br><span class="line">    TimeUnit是一个枚举类型 ，包括以下属性：</span><br><span class="line">    </span><br><span class="line">    NANOSECONDS ： 1微毫秒 &#x3D; 1微秒 &#x2F; 1000 MICROSECONDS ： 1微秒 &#x3D; 1毫秒 &#x2F; 1000 MILLISECONDS ： 1毫秒 &#x3D; 1秒 &#x2F;1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天</span><br><span class="line">    </span><br><span class="line">BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象。</span><br><span class="line"></span><br><span class="line">    常用的几个阻塞队列：</span><br><span class="line">    </span><br><span class="line">    LinkedBlockingQueue</span><br><span class="line">    </span><br><span class="line">    链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。</span><br><span class="line">    </span><br><span class="line">    ArrayBlockingQueue</span><br><span class="line">    </span><br><span class="line">    数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</span><br><span class="line">    </span><br><span class="line">    SynchronousQueue</span><br><span class="line">    </span><br><span class="line">    同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</span><br><span class="line">    </span><br><span class="line">    DelayQueue</span><br><span class="line">    </span><br><span class="line">    延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素</span><br></pre></td></tr></table></figure><p>两个非必须的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory</span><br><span class="line"></span><br><span class="line">    创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂     </span><br><span class="line"></span><br><span class="line">RejectedExecutionHandler handler</span><br><span class="line"></span><br><span class="line">    拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</span><br></pre></td></tr></table></figure><h5 id="总结一下处理流程"><a href="#总结一下处理流程" class="headerlink" title="总结一下处理流程"></a>总结一下处理流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. 线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。注意，这一步需要获得全局锁。</span><br><span class="line">2. 线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。</span><br><span class="line">3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。</span><br><span class="line">4. 缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，       </span><br><span class="line">在while循环中，worker会不断地调用getTask方法从阻塞队列中获取任务然后调用task.run()执行任务,从而达到复用线程的目的。只要getTask方法不返回null,此线程就不会退出。</span><br><span class="line"></span><br><span class="line">核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果STOP或者TERMINATED，返回null</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">##### prestartAllCoreThreads 启动所有核心线程</span><br><span class="line"></span><br><span class="line">#####  线程池 拒绝策略有哪些</span><br><span class="line">RejectedExecutionHandler handler</span><br><span class="line"></span><br><span class="line">拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;ThreadPoolExecutor.AbortPolicy&#x3D;&#x3D;：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程(任务所属线程)处理该任务</span><br><span class="line"></span><br><span class="line">#### 2.2.1 线程池 阻塞队列 （CLH） 原理</span><br><span class="line">常用的几个阻塞队列：</span><br><span class="line">&#96;&#96;&#96;text</span><br><span class="line">LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。</span><br><span class="line"></span><br><span class="line">ArrayBlockingQueue</span><br><span class="line"></span><br><span class="line">数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</span><br><span class="line"></span><br><span class="line">SynchronousQueue</span><br><span class="line"></span><br><span class="line">同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</span><br><span class="line"></span><br><span class="line">DelayQueue</span><br><span class="line"></span><br><span class="line">延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素</span><br></pre></td></tr></table></figure><h4 id="2-2-2-各种锁接口-和实现类"><a href="#2-2-2-各种锁接口-和实现类" class="headerlink" title="2.2.2 各种锁接口 和实现类"></a>2.2.2 各种锁接口 和实现类</h4><h5 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h5><p>重入锁的概念 ；        </p><p>支持同一个线程对资源重复加锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;  作为重入计数器</span><br></pre></td></tr></table></figure><p>ReentrantLock 的中文意思就是可重入锁。</p><p>synchronized关键字就是使用的重入锁。<br>在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常</p><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>内部有一个抽象类Sync，是继承了AQS,<br>还有两个非抽象类NonfairSync和FairSync，它们都继承了Sync，都是独占式的排它锁</p><p>ReentrantLock支持非公平锁和公平锁两种。</p><h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>公平锁 ： FIFO, 先对锁获取请求的线程先被满足，后对锁获取请求的线程后被满足</p><p>而非公平锁新入的线程则可以先尝试获取锁，如果失败了再排队。</p><p>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</p><h5 id="读写锁和排它锁"><a href="#读写锁和排它锁" class="headerlink" title="读写锁和排它锁"></a>读写锁和排它锁</h5><p>排它锁 ：同一时刻只允许一个线程进行访问 , synchronized用的锁和ReentrantLock，其实都是“排它锁”</p><p>读写锁 ： 可以再同一时刻允许多个读线程访问。<br>Java提供了 ReentrantReadWriteLock 类作为读写锁的默认实现，<br>内部维护了两个锁：一个读锁，一个写锁。<br>通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p><p>在写线程访问时，所有的读线程和其它写线程均被阻塞</p><h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><p>JDK1.8 的StampedLock 的性能是非常优异的，基本上可以取代ReentrantReadWriteLock的作用。</p><h4 id="2-2-3-java-同步容器、线程安全的集合"><a href="#2-2-3-java-同步容器、线程安全的集合" class="headerlink" title="2.2.3 java 同步容器、线程安全的集合"></a>2.2.3 java 同步容器、线程安全的集合</h4><p>ConcurrentMap、阻塞队列（BlockingQueue）、CopyOnWrite容器（CopyOnWriteArrayList、 CopyOnWriteArraySet）</p><h5 id="concurrentHashMap-原理"><a href="#concurrentHashMap-原理" class="headerlink" title="concurrentHashMap 原理"></a>concurrentHashMap 原理</h5><p>ConcurrentMap接口继承了Map接口</p><p>ConcurrentHashMap同HashMap一样也是基于散列表的map</p><p>由 Hash值数组 + Node链表结构组成（链表也会在长度达到8的时候转化为红黑树）。<br>put数据时 以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，配合自旋+CAS避免不必要的锁开销，进一步提升并发性能。</p><p>采用了分段锁，将数据分段，对每一段数据分配一把锁。<br>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>有些方法需要跨段，比如 size()、isEmpty()、containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，<br>这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。</p><h5 id="ConcurrentHashMap-1-7和1-8的区别、jdk8对-ConcurrentHashMap-做了哪些优化"><a href="#ConcurrentHashMap-1-7和1-8的区别、jdk8对-ConcurrentHashMap-做了哪些优化" class="headerlink" title="ConcurrentHashMap 1.7和1.8的区别、jdk8对 ConcurrentHashMap 做了哪些优化"></a>ConcurrentHashMap 1.7和1.8的区别、jdk8对 ConcurrentHashMap 做了哪些优化</h5><ol><li><p>将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构， 避免链表过长</p></li><li><p>采用了分段锁，以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，<br>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p></li></ol><h5 id="concurrentHashMap-怎么实现线程安全，分段锁是jdk几提出的"><a href="#concurrentHashMap-怎么实现线程安全，分段锁是jdk几提出的" class="headerlink" title="concurrentHashMap 怎么实现线程安全，分段锁是jdk几提出的"></a>concurrentHashMap 怎么实现线程安全，分段锁是jdk几提出的</h5><p>JDK1.8提出分段锁，put时, synchronized 将Node链表的头节点作为锁，</p><p>在初始化数组时使用了 volatile + CAS + 自旋 操作 决定到底是哪个线程有资格进行初始化，其他线程均只能等待</p><h5 id="copyOnWrite原理"><a href="#copyOnWrite原理" class="headerlink" title="copyOnWrite原理"></a>copyOnWrite原理</h5><p>写时复制，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，<br>然后向新容器中添加我们需要的元素，<br>最后将原容器的引用指向新容器。</p><p>“读操作”是没有加锁，直接读取</p><p>适合读多写少的场景，缺点是复制原容器会占用两倍内存，不能保证实时一致性，只能保证最终一致性</p><h4 id="AtomicInteger-原子类的原理、AtomicInteger-怎么实现原子性"><a href="#AtomicInteger-原子类的原理、AtomicInteger-怎么实现原子性" class="headerlink" title="AtomicInteger 原子类的原理、AtomicInteger 怎么实现原子性"></a>AtomicInteger 原子类的原理、AtomicInteger 怎么实现原子性</h4><p>volatile 修改 int值， 底层通过 Unsafe类的 CAS操作尝试更新值</p><h4 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h4><h5 id="10-5-1-ABA问题"><a href="#10-5-1-ABA问题" class="headerlink" title="10.5.1 ABA问题"></a>10.5.1 ABA问题</h5><pre><code>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。ABA问题的解决思路是在变量前面追加上版本号或者时间戳。      从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。     </code></pre><h5 id="10-5-2-循环时间长开销大"><a href="#10-5-2-循环时间长开销大" class="headerlink" title="10.5.2 循环时间长开销大"></a>10.5.2 循环时间长开销大</h5><pre><code>CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。解决思路是让JVM支持处理器提供的pause指令。pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。      </code></pre><h5 id="10-5-3-只能保证一个共享变量的原子操作"><a href="#10-5-3-只能保证一个共享变量的原子操作" class="headerlink" title="10.5.3 只能保证一个共享变量的原子操作"></a>10.5.3 只能保证一个共享变量的原子操作</h5><pre><code>这个问题你可能已经知道怎么解决了。有两种解决方案：使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；使用 synchronize 锁。锁内的临界区代码可以保证只有当前线程能操作      </code></pre><hr><h2 id="3-Mysql"><a href="#3-Mysql" class="headerlink" title="3 Mysql"></a>3 Mysql</h2><h3 id="3-1-sql优化的思路"><a href="#3-1-sql优化的思路" class="headerlink" title="3.1 sql优化的思路"></a>3.1 sql优化的思路</h3><p>优化索引的使用，减少全表扫描，减少回表次数</p><ul><li>在 where条件字段，join 关联字段、order by 字段、建立索引</li><li>查询具体列名，不用select *</li><li>避免在查询列使用 函数</li><li>避免隐式转换</li><li>如果出现OR的一个条件没有索引时，建议使用 union 或建立联合索引</li></ul><h4 id="InnoDB有两大类索引："><a href="#InnoDB有两大类索引：" class="headerlink" title="InnoDB有两大类索引："></a>InnoDB有两大类索引：</h4><p>聚集索引(clustered index)</p><p>普通索引(secondary index)</p><h4 id="聚簇索引（clustered-index）与非聚簇索引（secondary-index）的区别-？"><a href="#聚簇索引（clustered-index）与非聚簇索引（secondary-index）的区别-？" class="headerlink" title="聚簇索引（clustered index）与非聚簇索引（secondary index）的区别 ？"></a>聚簇索引（clustered index）与非聚簇索引（secondary index）的区别 ？</h4><p>1、聚簇索引（clustered index)<br>a) 一个索引项直接对应实际数据记录的存储页，可谓“直达”，行数据就储存在索引树的叶子节点上<br>b) 主键缺省使用它<br>c) 索引项的排序和数据行的存储排序完全一致，利用这一点，想修改数据的存储顺序，可以通过改变主键的方法（撤销原有主键，另找也能满足主键要求的一个字段或一组字段，重建主键）<br>d) 一个表只能有一个聚簇索引（理由：数据一旦存储，顺序只能有一种）</p><p>2、非聚簇索引（secondary index）<br>a) 索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找<br>b) 一个表可以有多个非聚簇索引</p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>先定位主键值，再定位行记录，扫描两遍索引树，它的性能较扫一遍索引树更低。</p><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p><p>常见的方法是：将被查询的字段，建立到联合索引里去。</p><h3 id="3-2-慢查询的处理方法、关注的字段（type、key、extra）"><a href="#3-2-慢查询的处理方法、关注的字段（type、key、extra）" class="headerlink" title="3.2 慢查询的处理方法、关注的字段（type、key、extra）"></a>3.2 慢查询的处理方法、关注的字段（type、key、extra）</h3><p>分析慢查询的执行计划，explain 查看 type 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><p>key列显示索引实际决定使用的键，没有使用索引时 值为null</p><p>如果 Extra字段为 Using index condition ，可以通过建立联合索引，优化为 Using index</p><h3 id="3-3-事务隔离级别"><a href="#3-3-事务隔离级别" class="headerlink" title="3.3 事务隔离级别"></a>3.3 <a href="https://mp.weixin.qq.com/s/mZxAn7qRQ8EycVOcdql3hQ" target="_blank" rel="noopener">事务隔离级别</a></h3><h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h5><p>可能出现脏读（读取到其他事务未提交的数据）、</p><p>不能重复读： 在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）</p><p>幻读：在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除</p><h5 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h5><p>可能出现 幻读、不可重复读</p><h5 id="可重复读（mysql-innoDB-采用）"><a href="#可重复读（mysql-innoDB-采用）" class="headerlink" title="可重复读（mysql innoDB 采用）"></a>可重复读（mysql innoDB 采用）</h5><p>可能出现 幻读</p><h5 id="串行读"><a href="#串行读" class="headerlink" title="串行读"></a>串行读</h5><p>最严格的的隔离级别，并发效率低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##### 脏读</span><br><span class="line">A事务读取到B事务未提交的数据</span><br><span class="line"></span><br><span class="line">##### 不可重复读 （行级锁可以处理这个问题）</span><br><span class="line">A事务内相同条件多次读取，由于B事务修改数据，导致多次读取结果值不一致</span><br><span class="line"></span><br><span class="line">##### 幻读 (表级锁可以处理这个问题)</span><br><span class="line">A事务内相同条件多次读取，由于B事务新增或者删除数据，导致多次读取结果总数不一致</span><br></pre></td></tr></table></figure><h4 id="3-4-sql-使用"><a href="#3-4-sql-使用" class="headerlink" title="3.4 sql 使用"></a>3.4 sql 使用</h4><h4 id="对于join-和-left-join-，-on-和where的结果有没有区别"><a href="#对于join-和-left-join-，-on-和where的结果有没有区别" class="headerlink" title="对于join 和 left join ， on 和where的结果有没有区别"></a>对于join 和 left join ， on 和where的结果有没有区别</h4><p>使用内连接（inner join / join）时没有区别  </p><h5 id="使用外连接（left-join-right-join）有区别"><a href="#使用外连接（left-join-right-join）有区别" class="headerlink" title="使用外连接（left join / right join）有区别"></a>使用外连接（left join / right join）有区别</h5><p>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    dep.dept_no</span><br><span class="line">    ,dep.emp_no</span><br><span class="line">    ,sal.salary</span><br><span class="line">    ,dep.from_date</span><br><span class="line">    ,dep.to_date</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    dept_manager dep</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> salaries sal</span><br><span class="line">    <span class="keyword">on</span> dep.emp_no = sal.emp_no</span><br><span class="line">    <span class="keyword">and</span> dep.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">and</span> sal.to_date = <span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure><p>where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正确栗子</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    dep.dept_no</span><br><span class="line">    ,dep.emp_no</span><br><span class="line">    ,sal.salary</span><br><span class="line">    ,dep.from_date</span><br><span class="line">    ,dep.to_date</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    dept_manager dep</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> salaries sal</span><br><span class="line">    <span class="keyword">on</span> dep.emp_no = sal.emp_no</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    dep.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">and</span> sal.to_date = <span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure><h4 id="3-5-InnoDB与MyISAM对比"><a href="#3-5-InnoDB与MyISAM对比" class="headerlink" title="3.5 InnoDB与MyISAM对比"></a>3.5 InnoDB与MyISAM对比</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ceNmtYOhbMQs4Ar4C7lr5CFmTkzO5qFP4ziaEN8O2vgic8ibP9RnGibTDcVaAxTKfTxeicpCrYquzWXRstmdviaCrSzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></p><h3 id="innoDB怎么实现的ACID特性-、-Atomicity-原子性-Consistency-一致性-Isolation-隔离性-Transaction-持久性"><a href="#innoDB怎么实现的ACID特性-、-Atomicity-原子性-Consistency-一致性-Isolation-隔离性-Transaction-持久性" class="headerlink" title="innoDB怎么实现的ACID特性 、 Atomicity(原子性),Consistency(一致性),Isolation(隔离性),Transaction(持久性)"></a>innoDB怎么实现的ACID特性 、 Atomicity(原子性),Consistency(一致性),Isolation(隔离性),Transaction(持久性)</h3><p>通过事务控制，事务的本质就是锁和并发和重做日志的结合体</p><p>redo日志记录了数据变化的每一个动作，数据库锁保证了事务的隔离性，持有锁的事务才能修改数据</p><h3 id="innoDB支持几种锁"><a href="#innoDB支持几种锁" class="headerlink" title="innoDB支持几种锁"></a>innoDB支持几种锁</h3><p>一种是行级锁，一种是意向锁（表级别的锁）</p><ul><li>意向共享锁（读锁 IS Lock），事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（写锁 IX Lock），事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><h3 id="innoDB的标准行级锁有哪两种"><a href="#innoDB的标准行级锁有哪两种" class="headerlink" title="innoDB的标准行级锁有哪两种"></a>innoDB的标准行级锁有哪两种</h3><p>共享锁（读锁 S Lock），允许事务读一行数据<br>排它锁（写锁 X Lock），允许事务删除一行数据或者更新一行数据</p><h3 id="B-树叶子节点存的是什么"><a href="#B-树叶子节点存的是什么" class="headerlink" title="B+树叶子节点存的是什么"></a>B+树叶子节点存的是什么</h3><p>主键KEY或者具体行数据</p><hr><h2 id="4-Spring"><a href="#4-Spring" class="headerlink" title="4 Spring"></a>4 Spring</h2><h3 id="spring-和-spring-boot的区别"><a href="#spring-和-spring-boot的区别" class="headerlink" title="spring 和 spring boot的区别"></a>spring 和 spring boot的区别</h3><ol><li><p>内嵌了如Tomcat，Jetty这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</p></li><li><p>无需再像Spring那样搞一堆繁琐的xml文件的配置</p></li><li><p>整合常用依赖，提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自动引入其他依赖</p></li></ol><h3 id="四种方式配置Bean"><a href="#四种方式配置Bean" class="headerlink" title="四种方式配置Bean"></a>四种方式配置Bean</h3><p>基于XML配置、注解配置、java类配置、Groovy DSL配置</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p><a href="https://www.jianshu.com/p/8bb67ca11831" target="_blank" rel="noopener">Spring 如何解决循环依赖的问题</a></p><p><a href="https://blog.csdn.net/hezuo1181/article/details/82831080" target="_blank" rel="noopener">面试官：spring循环依赖是怎么解决的？</a></p><h4 id="扫描注解定义的Bean"><a href="#扫描注解定义的Bean" class="headerlink" title="扫描注解定义的Bean"></a>扫描注解定义的Bean</h4><p>@Controller 、 @Service  、 @Repository 、@Component</p><h4 id="自动装配Bean"><a href="#自动装配Bean" class="headerlink" title="自动装配Bean"></a>自动装配Bean</h4><p>使用 @Autowired 默认按类型注入， 有多个相同类型时可以用 @Qualifier 指定Bean name</p><p>也可以使用 @Resource（按名称注入） 、 @Inject（按类型） </p><p>可以对类成员、方法标注 @Autowired，</p><p>@Order 指定相同类型的Bean的加载顺序，值越小越优先</p><h5 id="延迟依赖注入"><a href="#延迟依赖注入" class="headerlink" title="延迟依赖注入"></a>延迟依赖注入</h5><p>在class 和属性上同时标注 @lazy</p><h4 id="Bean的作用范围、生命过程"><a href="#Bean的作用范围、生命过程" class="headerlink" title="Bean的作用范围、生命过程"></a>Bean的作用范围、生命过程</h4><p>默认作用范围是 singleton 单例， 可以使用 @Scope(“prototype) 修改</p><p>在Bean实例化和属性注入完成后，执行 @PostConstruct 修饰的初始化方法</p><p>在容器关闭时，执行 @PreDestroy 修饰的方法</p><h4 id="基于Java-类的配置-Configuration"><a href="#基于Java-类的配置-Configuration" class="headerlink" title="基于Java 类的配置  @Configuration"></a>基于Java 类的配置  @Configuration</h4><p>@Configuration 本身标注了 @Component ，可以像普通Bean一样注入</p><p>普通的 POJO 只需要标注 @Configuration ，就可以为 Spring容器 提供bean定义<br>每个标注了 @Bean的类型方法 相当于提供了一个Bean的定义信息</p><p>Spring会对配置类标注了 @Bean的方法进行 Bean的实例化</p><h4 id="使用基于-Java类的配置信息-启动Spring容器"><a href="#使用基于-Java类的配置信息-启动Spring容器" class="headerlink" title="使用基于 Java类的配置信息 启动Spring容器"></a>使用基于 Java类的配置信息 启动Spring容器</h4><p>通过 AnnotationConfigApplicationContext 的 register() 方法，<br>然后调用 refresh() 方法</p><p>可以通过 @Import 注解 将多个配置类 组装到一个配置类</p><h3 id="通过编码方式动态添加-Bean"><a href="#通过编码方式动态添加-Bean" class="headerlink" title="通过编码方式动态添加 Bean"></a>通过编码方式动态添加 Bean</h3><h4 id="通过DefaultListableBeanFactory"><a href="#通过DefaultListableBeanFactory" class="headerlink" title="通过DefaultListableBeanFactory"></a>通过DefaultListableBeanFactory</h4><p> 动态注入Bean，使Bean被AOP增强， 需要实现BeanFactoryPostProcessor#postProcessBeanFactory()，</p><h3 id="AOP的原理、应用"><a href="#AOP的原理、应用" class="headerlink" title="AOP的原理、应用"></a>AOP的原理、应用</h3><p>动态代理，通过定义切面和增强，完成目标方法的增强       </p><ol><li><p>JDK动态代理，运行期完成，需要目标类实现接口，并且被拦截的方法在接口中有定义，通过反射生成接口的实现类，<br>生成快，运行效率低，适合非单例的Bean</p></li><li><p>cglib代理 ，运行期完成，动态创建子类，不能代理final、private方法，不需要目标类实现接口，生成慢，运行效率高，适合单例缓存池的Bean生成</p></li></ol><h3 id="Spring如何选择两种代理模式的？"><a href="#Spring如何选择两种代理模式的？" class="headerlink" title="Spring如何选择两种代理模式的？"></a>Spring如何选择两种代理模式的？</h3><pre><code>1、如果目标对象实现了接口，则默认采用JDK动态代理；2、如果目标对象没有实现接口，则使用Cglib代理；3、如果目标对象实现了接口，但强制使用了Cglib，则使用Cglib进行代理</code></pre><h4 id="4-2-Spring-事务"><a href="#4-2-Spring-事务" class="headerlink" title="4.2 Spring 事务"></a>4.2 Spring 事务</h4><p>事务模板类 TransactionTemplate 配合 事务回调 TransactionCallback 指定具体的持久化操作</p><p>TransactionDefinition：Spring支持的事务属性</p><p>TransactionStatus：代表事务具体运行状态</p><p>PlatformTransactionManager：事务管理抽象接口，提交、回滚；<br>不同的持久化框架有不同的实现类</p><p>重要的类 ： TransactionAspectSupport</p><h5 id="事务同步管理器"><a href="#事务同步管理器" class="headerlink" title="事务同步管理器"></a>事务同步管理器</h5><p>通过多个ThreadLocal变量保存线程不安全的事务相关的变量</p><h5 id="Spring事务的实现原理，嵌套事务的实现原理"><a href="#Spring事务的实现原理，嵌套事务的实现原理" class="headerlink" title="Spring事务的实现原理，嵌套事务的实现原理"></a>Spring事务的实现原理，嵌套事务的实现原理</h5><p>通过AOP实现， Spring将事务管理的步骤 织入业务方法的连接点，<br>比如获取线程绑定资源、开始事务、提交/回滚事务、异常处理</p><p>通过多个ThreadLocal变量保存线程不安全的事务相关的变量</p><p>设置保存点，可以回滚到保存点</p><h5 id="回滚设置"><a href="#回滚设置" class="headerlink" title="回滚设置"></a>回滚设置</h5><p>运行期异常引发回滚，检查型异常不会引发回滚</p><h5 id="Transaction-应用位置"><a href="#Transaction-应用位置" class="headerlink" title="@Transaction 应用位置"></a>@Transaction 应用位置</h5><p>在方法上使用时，方法上的配置会覆盖类上的配置</p><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><p>保存线程本地化的容器，<br>运行于多线程环境的某个对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本</p><h5 id="Spring事务的隔离级别？-默认值？"><a href="#Spring事务的隔离级别？-默认值？" class="headerlink" title="Spring事务的隔离级别？ 默认值？"></a>Spring事务的隔离级别？ 默认值？</h5><p>TransactionDefinition :<br>定义了与java.lang.sql同名的四个隔离级别，<br>还有一个 默认的隔离级别表示使用底层数据库的默认隔离级别</p><h5 id="Spring事务的传播属性？-默认值？"><a href="#Spring事务的传播属性？-默认值？" class="headerlink" title="Spring事务的传播属性？ 默认值？"></a>Spring事务的传播属性？ 默认值？</h5><p>默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Propagation propagation() default Propagation.REQUIRED;</span><br><span class="line">如果当前没有事务，新建一个事务，如果已经存在一个事务，加入到这个事务</span><br></pre></td></tr></table></figure><p>7种类型的事务传播行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_REQUIRED ：如果当前没有事务，新建一个事务，如果已经存在一个事务，加入到这个事务</span><br><span class="line"></span><br><span class="line">PROPAGATION_SUPPORTS ：如果当前有事务，加入这个事务，否则以非事务方式运行</span><br><span class="line"></span><br><span class="line">PROPAGATION_MANDATORY : 如果当前有事务，加入这个事务，否则抛出异常</span><br><span class="line"></span><br><span class="line">PROPAGATION_REQUIRES_NEW ： 新建事务，挂起当前事务</span><br><span class="line"></span><br><span class="line">PROPAGATION_NOT_SUPPORTED ：不允许事务，如果当前有事务，抛出异常</span><br><span class="line"></span><br><span class="line">PROPAGATION_NEVER ：如果当前没有事务，新建一个事务，如果已经存在一个事务，新建一个事务保存点</span><br><span class="line"></span><br><span class="line">PROPAGATION_NESTED： 使用嵌套事务时，底层数据源需要基于JDBC3.0，支持保存点</span><br></pre></td></tr></table></figure><h5 id="spring-事务不生效-Transactional注解无效-的场景"><a href="#spring-事务不生效-Transactional注解无效-的场景" class="headerlink" title="spring 事务不生效(@Transactional注解无效)的场景"></a>spring 事务不生效(@Transactional注解无效)的场景</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 如果不是Innodb存储引擎，MyISAM不支持事务。</span><br><span class="line"></span><br><span class="line">2. 没有指定rollbackFor参数默认只会捕获RuntimeException 和 Error 来进行回滚。</span><br><span class="line"></span><br><span class="line">3. 没有指定transactionManager参数，默认的transactionManager并不是我期望的，以及一个事务中涉及到了多个数据库。</span><br><span class="line"></span><br><span class="line">4. 如果AOP使用了JDK动态代理，对象内部方法互相调用不会被Spring的AOP拦截，另外代理 public static 方法无效（接口不能定义静态方法，而JDK动态代理是生成接口的子类）</span><br><span class="line"></span><br><span class="line">5. 如果AOP使用了CGLIB代理，事务方法或者类不是public（private static final），无法被外部包访问到，或者是final无法继承，@transactional注解无效</span><br></pre></td></tr></table></figure><h3 id="SpringBoot-自动装配的原理"><a href="#SpringBoot-自动装配的原理" class="headerlink" title="SpringBoot 自动装配的原理"></a>SpringBoot 自动装配的原理</h3><p>Spring Boot在启动的时候</p><ol><li>会将主配置类（即@SpringBootApplication标注的类）的所在包及子包里面所有组件扫描加载到Spring容器</li><li>会从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，<br>将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。<br>以前我们需要自己配置的东西，自动配置类都帮我们完成了</li></ol><h3 id="springboot的启动流程"><a href="#springboot的启动流程" class="headerlink" title="springboot的启动流程"></a>springboot的启动流程</h3><p>构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：</p><p>1.把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数。</p><p>2.判断是否是web程序，并设置到webEnvironment这个boolean属性中。 </p><p>3.找出所有的初始化器，默认有5个，设置到initializers属性中 。</p><p>4.找出所有的应用程序监听器，默认有9个，设置到listeners属性中 。</p><p>5.找出运行的主类(main class) 。</p><p>SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事：</p><p>1.构造一个StopWatch，观察SpringApplication的执行 。</p><p>2.找出所有的SpringApplicationRunListener并封装到SpringApplicationRunListeners中，用于监听run方法的执行。监听的过程中会封装成事件并广播出去让初始化过程中产生的应用程序监听器进行监听 。</p><p>3.构造Spring容器(ApplicationContext)，并返回 。</p><pre><code>3.1 创建Spring容器的判断是否是web环境，是的话构造AnnotationConfigEmbeddedWebApplicationContext，否则构造 AnnotationConfigApplicationContext 。3.2 初始化过程中产生的初始化器在这个时候开始工作 。3.3 Spring容器的刷新(完成bean的解析、各种processor接口的执行、条件注解的解析，aware接口的回调 等等) 。</code></pre><p>4.从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行。</p><hr><h2 id="5-Mybatis"><a href="#5-Mybatis" class="headerlink" title="5 Mybatis"></a>5 Mybatis</h2><h3 id="1-为什么要用-mybatis-这种持久层框架？"><a href="#1-为什么要用-mybatis-这种持久层框架？" class="headerlink" title="1. 为什么要用 mybatis 这种持久层框架？"></a>1. 为什么要用 mybatis 这种持久层框架？</h3><ol><li><p>原始的JDBC 访问数据库，没有用到数据库连接池，频繁创建销毁连接影响效率        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis 内部实现了 数据库连接池</span><br></pre></td></tr></table></figure></li><li><p>sql、配置文件耦合在代码里，不方便全局修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis 通过读取配置信息，赋值给 Configuration， </span><br><span class="line"></span><br><span class="line">全局单例配置对象 SqlSessionFactory 持有 Configuration</span><br></pre></td></tr></table></figure></li><li><p>消除了重复的模板代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 获取连接，参数替换</span><br><span class="line">2. 释放连接</span><br><span class="line">3. 处理异常</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-自己怎么实现mybatis，实现原理"><a href="#2-自己怎么实现mybatis，实现原理" class="headerlink" title="2. 自己怎么实现mybatis，实现原理"></a>2. 自己怎么实现mybatis，实现原理</h3><ol><li><p>获取数据库连接</p></li><li><p>获取sql，参数替换</p></li><li><p>执行sql，处理返回值</p></li></ol><h3 id="3-mybatis-一二级缓存配置"><a href="#3-mybatis-一二级缓存配置" class="headerlink" title="3. mybatis 一二级缓存配置"></a>3. mybatis 一二级缓存配置</h3><ol><li><p>默认开启，一级缓存是Session会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）；</p></li><li><p>二级缓存是 每一个Mapper都可以拥有一个Cache对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. 该select语句所在的Mapper，配置了&lt;cache&gt; 或&lt;cached-ref&gt;节点，并且有效</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>. 该select语句的参数 useCache=<span class="keyword">true</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="6-Rabbit-MQ"><a href="#6-Rabbit-MQ" class="headerlink" title="6 Rabbit MQ"></a>6 Rabbit MQ</h2><h3 id="Rabbit-MQ-架构设计"><a href="#Rabbit-MQ-架构设计" class="headerlink" title="Rabbit MQ 架构设计"></a>Rabbit MQ 架构设计</h3><p>生产者、信道（交换器、绑定、队列）、消费者</p><p>集群模式，至少一个磁盘节点</p><h3 id="如果-Rabbit-MQ-挂掉了，后续流程怎么处理"><a href="#如果-Rabbit-MQ-挂掉了，后续流程怎么处理" class="headerlink" title="如果 Rabbit MQ 挂掉了，后续流程怎么处理"></a>如果 Rabbit MQ 挂掉了，后续流程怎么处理</h3><p>搭建 Rabbit集群， Rabbit集群允许消费者和生产者在单个Rabbit MQ节点崩溃时 继续运行， </p><p>如果集群中唯一的磁盘节点崩溃的话，集群仍然可以保持运行，但是无法更改任何东西<br>可以在集群中设置多个磁盘节点</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>如果消息要从 MQ重启后恢复，消息必须</p><ol><li>投递模式选项设置为2 （持久）</li><li>发送到持久化的交换器（durable 为 true）</li><li>达到持久化的队列（durable 为 true）</li></ol><p>MQ确保消息能从服务器重启中恢复的方式是 把消息写入磁盘上的一个持久化日志文件，<br>当发送一条持久化消息到交换器，Rabbit MQ 会在消息保存到日志文件后发送响应</p><p>Rabbit MQ 会在消费者消费后把持久化消息标记为等待垃圾回收</p><p>在消费之前，如果 Rabbit MQ重启，Rabbit MQ会重播日志文件中的消息到对应的队列 或者交换器</p><p>持久化消息到磁盘会影响吞吐效率</p><h3 id="Rabbit-MQ-如何保证消息正确投递"><a href="#Rabbit-MQ-如何保证消息正确投递" class="headerlink" title="Rabbit MQ 如何保证消息正确投递"></a>Rabbit MQ 如何保证消息正确投递</h3><h5 id="1、生产者丢数据"><a href="#1、生产者丢数据" class="headerlink" title="1、生产者丢数据"></a>1、生产者丢数据</h5><p>RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p><p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p><p>然而缺点就是吞吐量下降了，生产上用confirm模式的居多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)</span><br><span class="line"></span><br><span class="line">一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)</span><br><span class="line"></span><br><span class="line">这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</span><br><span class="line"></span><br><span class="line">相关接口 ：</span><br><span class="line">org.springframework.amqp.core.AmqpTemplate#convertSendAndReceive(java.lang.String, java.lang.String, java.lang.Object, org.springframework.amqp.core.MessagePostProcessor)</span><br></pre></td></tr></table></figure><h5 id="2、消息队列丢数据"><a href="#2、消息队列丢数据" class="headerlink" title="2、消息队列丢数据"></a>2、消息队列丢数据</h5><p>开启持久化磁盘的配置，在消息持久化磁盘后，再给生产者发送一个Ack信号。</p><p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p><p>如何持久化呢，下面两步</p><p>1、将queue的持久化标识durable设置为true,则代表是一个持久的队列</p><p>2、发送消息的时候将deliveryMode=2</p><h5 id="3、消费者丢数据"><a href="#3、消费者丢数据" class="headerlink" title="3、消费者丢数据"></a>3、消费者丢数据</h5><p>消费者丢数据一般是因为采用了自动确认消息模式。</p><p>这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。</p><p>至于解决方案，==采用手动确认消息即可==  </p><h3 id="如何保证消息不被重复消费？"><a href="#如何保证消息不被重复消费？" class="headerlink" title="如何保证消息不被重复消费？"></a>如何保证消息不被重复消费？</h3><p>这个问题其实换一种问法就是，如何保证消息队列的幂等性?</p><p><strong>正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除</strong></p><p>RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念</p><h4 id="造成重复消费的原因"><a href="#造成重复消费的原因" class="headerlink" title="造成重复消费的原因?"></a>造成重复消费的原因?</h4><p> 就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者</p><h4 id="针对业务场景来答分以下几点"><a href="#针对业务场景来答分以下几点" class="headerlink" title="针对业务场景来答分以下几点"></a>针对业务场景来答分以下几点</h4><p>1、比如，你拿到这个消息做数据库的insert操作。</p><p>那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p><p>2、再比如，你拿到这个消息做redis的set的操作</p><p>那就容易了，不用解决。因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</p><p>3、如果上面两种情况还不行，上大招。</p><p>准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录 </p><h3 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h3><p>通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(rabbitMq中就是queue)。<br>然后只用一个消费者去消费该队列。</p><hr><h2 id="7-Redis"><a href="#7-Redis" class="headerlink" title="7 Redis"></a>7 Redis</h2><h3 id="为什么单线程更加快"><a href="#为什么单线程更加快" class="headerlink" title="为什么单线程更加快"></a>为什么单线程更加快</h3><ul><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU<ul><li>不用去考虑各种锁的问题，不存在加锁释放锁操作</li></ul></li><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li><li>数据结构简单，对数据操作也简单</li><li>使用多路I/O复用模型，非阻塞IO<ul><li>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，</li></ul></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p><p>Redis进行持久化的时候会以子进程或者子线程的方式执行        </p><h3 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h3><h4 id="快照模式（RDB）"><a href="#快照模式（RDB）" class="headerlink" title="快照模式（RDB）"></a>快照模式（RDB）</h4><p>在写操作不是特别频繁，允许丢失部分数据的场景下，<br>设置 每隔一段时间，达到一定写操作数量 ，进行自动保存，生成快照文件，或者进行手动保存</p><ul><li>save</li><li>bgsave ： fork子进程保存快照</li></ul><h4 id="AOF（Append-Only-File）-模式"><a href="#AOF（Append-Only-File）-模式" class="headerlink" title="AOF（Append Only File） 模式"></a>AOF（Append Only File） 模式</h4><p>同步写选项、同步频率</p><ul><li>always<br>  每个写命令都同步写入硬盘，会严重降低Redis 速度</li><li>everysec<br>  每秒执行一次同步，将多个写命令同步到硬盘</li><li>no<br>  让操作系统决定何时同步，不推荐</li></ul><h3 id="主从配置、哨兵模式，集群模式"><a href="#主从配置、哨兵模式，集群模式" class="headerlink" title="主从配置、哨兵模式，集群模式"></a>主从配置、哨兵模式，集群模式</h3><p>==只有主服务器接受写命令==</p><h4 id="更换故障主服务器"><a href="#更换故障主服务器" class="headerlink" title="更换故障主服务器"></a>更换故障主服务器</h4><h5 id="方法一：升级当前从服务器为主服务器"><a href="#方法一：升级当前从服务器为主服务器" class="headerlink" title="方法一：升级当前从服务器为主服务器"></a>方法一：升级当前从服务器为主服务器</h5><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><ol><li>复制从服务器数据到新的机器，</li><li>在新的机器上启动redis</li><li>为从服务器指定新的主服务器</li></ol><h4 id="redis集群是如何同步数据的？"><a href="#redis集群是如何同步数据的？" class="headerlink" title="redis集群是如何同步数据的？"></a>redis集群是如何同步数据的？</h4><h4 id="Redis复制过程"><a href="#Redis复制过程" class="headerlink" title="Redis复制过程"></a>Redis复制过程</h4><p>SLAVEOF host port 设置当前服务器为 某台服务器的从服务器</p><ol><li>从服务器连接主服务器，发送SYNC命令</li><li>主服务器执行 BGSAVE,在缓存区记录BGSAVE之后写入的命令，<br>从服务器会根据配置选择清空自身数据，或向客户端返回错误</li></ol><p>可以为从服务器指定新的从服务器，构成从服务器树</p><h4 id="哨兵模式-Redis-Sentinel"><a href="#哨兵模式-Redis-Sentinel" class="headerlink" title="哨兵模式 Redis Sentinel"></a>哨兵模式 Redis Sentinel</h4><p>目的是为了提供自动故障转移服务</p><p>配合Redis复制功能，Redis Sentinel是运行在特殊模式下的服务器<br>它会监视一系列主服务器和对应的从服务器，<br>==当主服务器失效时==，监视这个主服务器的所有Sentinel会基于彼此共有的信息选出一个新的主服务器，<br>其他的从服务器会去复制这个新的主服务器</p><h3 id="缓存雪崩和失效的场景"><a href="#缓存雪崩和失效的场景" class="headerlink" title="缓存雪崩和失效的场景"></a>缓存雪崩和失效的场景</h3><p>热点缓存key失效，大量请求直接访问数据库，导致数据库连接耗尽；</p><p>解决方案：</p><ul><li>查询前参数合理性校验</li><li>设置不同的过期时间</li><li>在查询数据库数据之前再查一遍redis（双重检查），查询数据库之后，新建redis缓存，设置过期时间 </li><li>应对大规模查询（应对秒杀活动），将查询放入消息队列</li></ul><hr><h2 id="8-SpringCloud-中间件"><a href="#8-SpringCloud-中间件" class="headerlink" title="8 SpringCloud 中间件"></a>8 SpringCloud 中间件</h2><h3 id="服务注册、服务发现-Eureka"><a href="#服务注册、服务发现-Eureka" class="headerlink" title="服务注册、服务发现 Eureka"></a>服务注册、服务发现 Eureka</h3><p>拉去Eureka服务端配置，并且不注册自身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: <span class="keyword">false</span></span><br><span class="line">    serviceUrl:</span><br><span class="line">      #      指定服务注册中心的地址</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8061/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="Http客户端-Feign"><a href="#Http客户端-Feign" class="headerlink" title="Http客户端 Feign"></a>Http客户端 Feign</h3><h4 id="Feign设置超时时间"><a href="#Feign设置超时时间" class="headerlink" title="Feign设置超时时间"></a>Feign设置超时时间</h4><p>使用Feign调用接口分两层，ribbon的调用和hystrix的调用，所以ribbon的超时时间和Hystrix的超时时间的结合就是Feign的超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#hystrix的超时时间</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">              timeout:</span><br><span class="line">                enabled: <span class="keyword">true</span></span><br><span class="line">              isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                        timeoutInMilliseconds: <span class="number">9000</span></span><br><span class="line">#ribbon的超时时间</span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: <span class="number">3000</span></span><br><span class="line">  ConnectTimeout: <span class="number">3000</span></span><br><span class="line">  MaxAutoRetries: 1 #同一台实例最大重试次数,不包括首次调用</span><br><span class="line">  MaxAutoRetriesNextServer: 1 #重试负载均衡其他的实例最大重试次数,不包括首次调用</span><br><span class="line">  OkToRetryOnAllOperations: false  #是否所有操作都重试 </span><br><span class="line"></span><br><span class="line">一般情况下 都是 ribbon 的超时时间（&lt;）hystrix的超时时间（因为涉及到ribbon的重试机制）</span><br><span class="line">因为ribbon的重试机制和Feign的重试机制有冲突，所以源码中默认关闭Feign的重试机制</span><br><span class="line"></span><br><span class="line">hystrix超时时间的计算： (<span class="number">1</span> + MaxAutoRetries + MaxAutoRetriesNextServer) * ReadTimeout </span><br><span class="line"></span><br><span class="line">当ribbon超时后且hystrix没有超时，便会采取重试机制。当OkToRetryOnAllOperations设置为<span class="keyword">false</span>时，只会对get请求进行重试。如果设置为<span class="keyword">true</span>，便会对所有的请求进行重试，如果是put或post等写操作，如果服务器接口没做幂等性，会产生不好的结果，所以OkToRetryOnAllOperations慎用。</span><br><span class="line"></span><br><span class="line">如果不配置ribbon的重试次数，默认会重试一次        </span><br><span class="line">注意：     </span><br><span class="line">默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试</span><br><span class="line">非GET方式请求,只有连接异常时,才会进行重试</span><br></pre></td></tr></table></figure><h3 id="负载均衡-ribbon、"><a href="#负载均衡-ribbon、" class="headerlink" title="负载均衡 ribbon、"></a>负载均衡 ribbon、</h3><h3 id="服务降级-Hystrix"><a href="#服务降级-Hystrix" class="headerlink" title="服务降级 Hystrix"></a>服务降级 Hystrix</h3><hr><h2 id="9-Zookeeper"><a href="#9-Zookeeper" class="headerlink" title="9 Zookeeper"></a>9 Zookeeper</h2><p>主节点失效，备份主节点需要通过选举，成为新的主节点，<br>如果旧的主节点恢复，==如何避免存在两个主节点（脑裂）==</p><p>从节点如果失效，主节点应该能够检测到，不在继续派发任务给失效节点，<br>重新派发未完成任务给其他节点，==如何避免重复消费==</p><p>主从节点 保持通信</p><h4 id="几个重要的-父znode"><a href="#几个重要的-父znode" class="headerlink" title="几个重要的 父znode"></a>几个重要的 父znode</h4><p>/workers  /assign     /tasks</p><h3 id="zookeeper-实现分布式锁"><a href="#zookeeper-实现分布式锁" class="headerlink" title="zookeeper 实现分布式锁"></a>zookeeper 实现分布式锁</h3><p>一个线程尝试创建 临时节点 /lock, (临时节点会在会话过期 或关闭时 自动被删除) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e &#x2F;lock &quot;&quot;</span><br></pre></td></tr></table></figure><p>其他线程因为节点存在，无法创建/lock<br>监听到 /lock 删除时，再次尝试创建 /lock，如果其他线程创建 /lock 成功，继续监听 /lock</p><h4 id="在主节点上增加监视点"><a href="#在主节点上增加监视点" class="headerlink" title="在主节点上增加监视点"></a>在主节点上增加监视点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat &#x2F;master true</span><br></pre></td></tr></table></figure><h4 id="设置-子节点的监视点"><a href="#设置-子节点的监视点" class="headerlink" title="设置 子节点的监视点"></a>设置 子节点的监视点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;workers true</span><br></pre></td></tr></table></figure><h4 id="Zookeeper一致性协议原理Zab-，ZAB（ZooKeeper-Atomic-Broadcast-）-全称为：原子消息广播协议"><a href="#Zookeeper一致性协议原理Zab-，ZAB（ZooKeeper-Atomic-Broadcast-）-全称为：原子消息广播协议" class="headerlink" title="Zookeeper一致性协议原理Zab ，ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议"></a>Zookeeper一致性协议原理Zab ，ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议</h4><p>ZAB可以说是在Paxos算法基础上进行了扩展改造而来的，ZAB协议设计了支持崩溃恢复</p><p>ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求，采用ZAB协议将服务器数状态 以事务形式 广播到所有Follower上；</p><h5 id="ZAB协议的两个基本模式：恢复模式和广播模式"><a href="#ZAB协议的两个基本模式：恢复模式和广播模式" class="headerlink" title="ZAB协议的两个基本模式：恢复模式和广播模式"></a>ZAB协议的两个基本模式：恢复模式和广播模式</h5><p>恢复模式:（选举）<br>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了</p><p>广播模式：（数据同步）<br>ZooKeeper服务一直维持在广播状态，直到Leader崩溃了或者Leader失去了大部分的Followers支持。</p><p>广播模式极其类似于分布式事务中的2pc（two-phrase commit 两阶段提交）：<br>即Leader提起一个决议，由Followers进行投票，Leader对投票结果进行计算决定是否通过该决议，如果通过执行该决议（事务），否则什么也不做</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="用过的设计模式有哪些"><a href="#用过的设计模式有哪些" class="headerlink" title="用过的设计模式有哪些"></a>用过的设计模式有哪些</h3><h2 id="10-性能优化"><a href="#10-性能优化" class="headerlink" title="10 性能优化"></a>10 性能优化</h2><h3 id="线上oom怎么排查-1"><a href="#线上oom怎么排查-1" class="headerlink" title="线上oom怎么排查"></a>线上oom怎么排查</h3><p>查看日志、分析dump文件，查看占用内存较多的对象</p><ol><li><p>ps -aux|grep java 当服务重新部署后，可以找出当前Java进程的PID</p></li><li><p>jstat -gcutil pid interval 用于查看当前GC的状态,它对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控</p></li><li><p>jmap -histo:live pid 可用统计存活对象的分布情况，从高到低查看占据内存最多的对象。上图</p></li><li><p>分析dump文件</p></li></ol><h4 id="如果一个-前端请求查询耗时很长，怎么优化"><a href="#如果一个-前端请求查询耗时很长，怎么优化" class="headerlink" title="如果一个 前端请求查询耗时很长，怎么优化"></a>如果一个 前端请求查询耗时很长，怎么优化</h4><ul><li>查看nginx日志，是否是网络问题</li><li>top命令查看 服务器内存 、IO情况，</li><li>查看服务日志，是否代码逻辑不合理，是否有多线程锁竞争</li><li>开启慢查询，是否有较慢的sql，能否优化查询，优化索引</li><li>热点数据是够可以缓存<br><img src="https://img-blog.csdnimg.cn/20190111141308700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdhZGFt,size_16,color_FFFFFF,t_70" alt="image"></li><li>第三方接口调用超时</li></ul><ul><li><p>线上内存溢出的场景和处理方法</p><ul><li>top定位查看服务器状态，获取占用内存多的进程ID，保存线程栈信息，</li><li>下载dump文件，分析 dump文件</li></ul></li><li><p>zookeeper / eureka 配置本地调用公共服务</p></li></ul><h4 id="nginx中的超时设置，请求超时、响应等待超时等"><a href="#nginx中的超时设置，请求超时、响应等待超时等" class="headerlink" title="nginx中的超时设置，请求超时、响应等待超时等"></a><a href="https://blog.csdn.net/qq_29663071/article/details/81061420" target="_blank" rel="noopener">nginx中的超时设置，请求超时、响应等待超时等</a></h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="从1000w个数字中找出最小的10个并打印"><a href="#从1000w个数字中找出最小的10个并打印" class="headerlink" title="从1000w个数字中找出最小的10个并打印"></a>从1000w个数字中找出最小的10个并打印</h4><p>advance.sort.HeapSort.findMinTopK</p><hr><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485070&idx=1&sn=31894a1bdda357d897962a9fc3a994b7&chksm=cea24945f9d5c0531db568321f1d8d7a4e848e04aa2df18e589db9ba4aafee0fb0cebb965252&token=463285003&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">记一次蚂蚁金服的面试经历</a></li></ul><p><a href="https://www.bilibili.com/read/cv5554230?share_medium=android&amp;share_source=weixin&amp;bbid=87E1A2EB-DC6F-4726-A9A5-51D5A927762310277infoc&amp;ts=1586753871769" target="_blank" rel="noopener">https://www.bilibili.com/read/cv5554230?share_medium=android&amp;share_source=weixin&amp;bbid=87E1A2EB-DC6F-4726-A9A5-51D5A927762310277infoc&amp;ts=1586753871769</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h2&gt;&lt;p&gt;我叫刘涛，2015年毕业后主要从事ETL、报表开发、图表可视化展现相关的工作，&lt;br&gt;参与了湖南农村信用社的 财务报表系统后
      
    
    </summary>
    
    
      <category term="2020" scheme="http://yoursite.com/categories/2020/"/>
    
      <category term="techframework" scheme="http://yoursite.com/categories/2020/techframework/"/>
    
    
      <category term="知识整理" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>书单,笔记,学习资源整理</title>
    <link href="http://yoursite.com/2020/05/23/youdao-notes-2017-10-20-%E4%B9%A6%E5%8D%95%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/23/youdao-notes-2017-10-20-%E4%B9%A6%E5%8D%95%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="所有的书到要心中有数"><a href="#所有的书到要心中有数" class="headerlink" title="所有的书到要心中有数"></a>所有的书到要心中有数</h2><p>学习笔记准备同步到github</p><ul><li>本地git仓库1<br>F:\Git\study\Pirate5946.github.io            对应<br><a href="https://github.com/Pirate5946/Pirate5946.github.io" target="_blank" rel="noopener">https://github.com/Pirate5946/Pirate5946.github.io</a></li><li>本地git仓库2<br>/f/project/project_code/study/study/            对应                                                                             <a href="https://github.com/Pirate5946/study/" target="_blank" rel="noopener">https://github.com/Pirate5946/study/</a></li></ul><h2 id="常用学习资源"><a href="#常用学习资源" class="headerlink" title="常用学习资源"></a>常用学习资源</h2><ul><li><p>收藏的学习博客    </p><ul><li><a href="http://blog.csdn.net/chenssy/article/month/2017/10" target="_blank" rel="noopener">死磕Java系列</a></li><li><a href="http://www.cnblogs.com/xrq730/" target="_blank" rel="noopener">Java 学习博客</a></li></ul></li><li><p>并发编程网</p></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">IBM Java学习文章 - JUnit5、Java8习惯用语、SpringBoot基础</a></p></li><li><p><a href="http://www.imooc.com/u/1070821/courses" target="_blank" rel="noopener">慕课网学习视频 - 多线程、servlet、hadoop、springboot</a></p></li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul><li><p>《编程之美 - 微软技术面试心得》</p></li><li><p>《剑指Offer - 名企面试官精讲典型编程题》<br><a href="https://www.nowcoder.com/ta/coding-interviews?query=&asc=true&order=&page=1" target="_blank" rel="noopener">剑指offer 配套在线编程试题 Java实现</a></p><h2 id="算法、数据结构"><a href="#算法、数据结构" class="headerlink" title="算法、数据结构"></a>算法、数据结构</h2></li><li><p>《算法 第四版》 Java实现<br><a href="https://www.coursera.org/learn/algorithms-part1" target="_blank" rel="noopener">普林斯顿大学公开课 算法第四版 配套视频</a></p></li><li><p><a href="https://www.nowcoder.com/ta/coding-interviews?query=&asc=true&order=&page=1" target="_blank" rel="noopener">牛客网 - 剑指offer 在线编程试题 Java实现</a></p></li><li><p><a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184_2X+sp/about" target="_blank" rel="noopener">数据结构-学堂在线- 清华 邓俊辉</a><br>正在学习第七章 二叉搜索树</p></li><li><p>《数据结构和Java集合框架》</p></li></ul><hr><h2 id="计算机组成原理-、-操作系统"><a href="#计算机组成原理-、-操作系统" class="headerlink" title="计算机组成原理 、 操作系统"></a>计算机组成原理 、 操作系统</h2><ul><li>计算机组成原理（第2版）唐朔飞</li><li><a href="http://www.xuetangx.com/courses/course-v1:NJU+C1026+2016_T2/courseware/3d91688693394170b793217762fcd4eb/" target="_blank" rel="noopener">学堂在线视频与笔记</a></li><li>linux 高级程序设计     </li></ul><hr><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java基础、提高"><a href="#Java基础、提高" class="headerlink" title="Java基础、提高"></a>Java基础、提高</h3><ul><li>《thinking in java》</li><li>《Effective Java中文版 第二版》 正在整理笔记</li><li>《Java 8 实战》 正在整理笔记</li></ul><h3 id="Java分布式"><a href="#Java分布式" class="headerlink" title="Java分布式"></a>Java分布式</h3><ul><li>《分布式Java应用 - 基础与实践》</li></ul><h3 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h3><ul><li><p>《Java多线程编程核心技术》 </p></li><li><p>《Java并发编程实战 》</p></li></ul><h3 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h3><ul><li>《深入理解 Java虚拟机 第二版》</li></ul><hr><h4 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h4><ul><li>《深入分析 JavaWeb 技术内幕- 淘宝 许令波》 好书，正在整理笔记</li></ul><hr><h2 id="spring-框架"><a href="#spring-框架" class="headerlink" title="spring 框架"></a>spring 框架</h2><ul><li>《spring实战 第四版》 正在整理笔记</li><li>《spring 揭秘》 </li></ul><hr><h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li>《深入浅出Python》</li><li>《Python CookBook》 有很多示例，可以跟着联系</li></ul><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="noopener">阮一峰-ECMAScript 6 第三版在线书籍</a></li><li>《JavaScript 权威指南》 正在整理笔记</li></ul><h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><ul><li>《高级Bash脚本编程指南》 ==先看完前89页并做笔记==</li></ul><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><ul><li>《涂抹Oracle-三思笔记 》 已经整理相关笔记</li></ul><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><ul><li>《涂抹Mysql - 三思笔记》 正在整理笔记</li></ul><hr><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li>Git权威指南</li><li>maven实战</li></ul><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul><li>HTTP 权威指南 前四章</li><li>《图解 HTTP》 知乎电子书</li></ul><hr><h2 id="C-（结合H盘学习文档）"><a href="#C-（结合H盘学习文档）" class="headerlink" title="C  （结合H盘学习文档）"></a>C  （结合H盘学习文档）</h2><ul><li>C与指针</li><li>C陷阱与缺陷.pdf</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>Head First 设计模式</li></ul><h3 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h3><ul><li>大型网站技术架构：核心原理与案例分析</li><li>Java核心技术 卷一 基础知识，第十版</li><li>Java8 实战</li><li>Spring实战 第四版</li><li>精通 Spring 4.x  企业应用开发实战</li><li>spring boot 实战</li><li>JavaEE开发的颠覆者：spring boor实战</li><li>springboot揭秘：快速构建微服务体系</li><li>实战Java高并发程序设计</li><li>redis 实战</li><li>redis 设计与实现</li><li>Java性能权威指南</li><li>有效的单元测试</li><li>重构：改善既有代码的设计</li><li>代码整洁之道</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;所有的书到要心中有数&quot;&gt;&lt;a href=&quot;#所有的书到要心中有数&quot; class=&quot;headerlink&quot; title=&quot;所有的书到要心中有数&quot;&gt;&lt;/a&gt;所有的书到要心中有数&lt;/h2&gt;&lt;p&gt;学习笔记准备同步到github&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地git仓库1&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>201710有道笔记整理</title>
    <link href="http://yoursite.com/2020/05/23/youdao-notes-2017-10-21-%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/23/youdao-notes-2017-10-21-%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-10-21-有道笔记整理"><a href="#2017-10-21-有道笔记整理" class="headerlink" title="2017-10-21-有道笔记整理"></a>2017-10-21-有道笔记整理</h2><p><img src="http://note.youdao.com/favicon.ico" alt="image">月阶段总结，时常回顾，用进废退</p><p><img src="http://ovybbprpf.bkt.clouddn.com/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86201710.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2017-10-21-有道笔记整理&quot;&gt;&lt;a href=&quot;#2017-10-21-有道笔记整理&quot; class=&quot;headerlink&quot; title=&quot;2017-10-21-有道笔记整理&quot;&gt;&lt;/a&gt;2017-10-21-有道笔记整理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
      <category term="书单整理" scheme="http://yoursite.com/categories/%E4%B9%A6%E5%8D%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Java基础特性" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8_ArrayList源码学习</title>
    <link href="http://yoursite.com/2020/05/23/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Java%E9%9B%86%E5%90%88%E5%8C%85-2017-09-12-ArrayList/"/>
    <id>http://yoursite.com/2020/05/23/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Java%E9%9B%86%E5%90%88%E5%8C%85-2017-09-12-ArrayList/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><a href="http://www.cnblogs.com/CherishFX/p/4725394.html" target="_blank" rel="noopener">参考文章— jdk1.8.0_45源码解读——ArrayList的实现</a><br><a href="http://blog.csdn.net/gulu_gulu_jp/article/details/51456969" target="_blank" rel="noopener">参考文章2—详细文字注释</a><br><a href="http://blog.csdn.net/u011392897/article/details/57105709" target="_blank" rel="noopener">参考文章3—图片分析</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">实际上java.util.ArrayList是个固定大小的对象，自身并不直接存储元素内容，而是持有一个引用&#x3D;&#x3D;element&#x3D;&#x3D;指向一个数组&#x3D;&#x3D;Object[]&#x3D;&#x3D;，真正负责存储元素内容的正是这个数组    </span><br><span class="line"></span><br><span class="line">定义了一个int值&#x3D;&#x3D;size&#x3D;&#x3D;表示数组的长度&#x3D;&#x3D;element.length&#x3D;&#x3D;    </span><br><span class="line"></span><br><span class="line">当需要扩容时，扩容的是这个数组，而不是ArrayList对象自身。(https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;48872729)</span><br><span class="line"></span><br><span class="line">- 线程不安全 modCount记录修改次数</span><br><span class="line"></span><br><span class="line">&gt; 构造函数初始化</span><br><span class="line"></span><br><span class="line">有三种构造器，原理是new一个object[]赋值给默认属性 elementData</span><br></pre></td></tr></table></figure><p>public ArrayList(int initialCapacity) //指定容量的 object[],不能小于0</p><p>public ArrayList() //默认初始化为 {}，空的数组</p><p>public ArrayList(Collection&lt;? extends E&gt; c) // </p><pre><code>&gt; 常用方法  ### 增加  - public void add(int index, E element)     往指定索引位置新增元素，确保索引没有越过上界和下界    检查长度+1后有没有超过数组  然后通过==system.arraycopy()方法==将位置为==index==的(==size-index==)个字符复制到到index+1的位置（相当于将原来的元素整体后移一位 ）- public boolean addAll(int index, Collection&lt;? extends E&gt; c)   原理跟 public void add(int index, E element)差不多，    检查增加Collection后，数组是否需要扩容      然后通过==system.arraycopy()方法==将原来从element[index]开始的size-index个元素复制到element[index+c.length]==往arraylist指向的数组中添加元素时会判断元素个数，小于10则初始化数组长度为10==- public boolean add(E e)检查元素个数+1后是否超出数组容量，超出则将数组容量增加一半（原容量右移一位）最后elementData[size++] = e- public boolean addAll(Collection&lt;? extends E&gt; c)      原理跟public boolean add(E e)差不多     获取c的长度，检查size+a.length的长度是否超过数组容量一半（原容量右移一位）==如果新增一半还不够，就新增size+c.length，不能超过int.MAX_VALUE==  最后将新增的元素复制到数组的末尾，size+=c.length### 删除- public E remove(int index)    //判断index是否 &lt;= size         //将数组elementData中index位置之后的所有元素向前移一位      //将原数组最后一个位置置为null，由GC清理- public boolean remove(Object o)   //移除ArrayList中首次出现的指定元素(如果存在)，ArrayList中允许存放重复的元素    // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。    如果要删除的元素是null，null没有equals方法，只能判断值    //私有的移除方法，跳过index参数的边界检查以及不返回任何值- protected void removeRange(int fromIndex, int toIndex)        //删除ArrayList中从fromIndex（包含）到toIndex（不包含）之间所有的元素，共移除了toIndex-fromIndex个元素- public boolean removeAll(Collection&lt;?&gt; c)     //删除ArrayList中包含在指定容器c中的所有元素        读写双指针，遍历整个数组，判断数组中元素与传入的集合中的元素是否有重合，把不包含在原集合的元素保留下来，==重合的元素删除==- public boolean retainAll(Collection&lt;?&gt; c)     //移除ArrayList中不包含在指定容器c中的所有元素，与removeAll(Collection&lt;?&gt; c)正好相反  把传入集合与原集合相同的元素保留下来，==不相同的元素删除==- public void clear()   //清空ArrayList，将全部的元素设为null### 获取- public E get(int index)   ### 修改- public E set(int index, E element)        检查索引是否越界        将旧索引值返回，旧索引指向新传入的元素### 查找元素- public boolean contains(Object o)       //遍历ArrayList，判断元素在集合中的索引值是否大于0- public int indexOf(Object o)      //正向查找，返回ArrayList中元素Object o第一次出现的位置，如果元素不存在，则返回-1- public int lastIndexOf(Object o)          //逆向查找，返回ArrayList中元素Object o最后一次出现的位置，如果元素不存在，则返回-1   - public E get(int index)       //返回指定索引处的元素### 其他public方法  - public void trimToSize()  //将底层数组的容量调整为当前列表保存的实际元素的大小的功能- public int size()     //返回ArrayList的大小（元素个数）- public boolean isEmpty()      //判断ArrayList是否为空- public Object clone()       //返回此 ArrayList实例的浅拷贝（modcount = 0）- public Object[] toArray()       //返回一个包含ArrayList中所有元素的数组- public &lt;T&gt; T[] toArray(T[] a)       //如果给定的参数数组长度足够，则将ArrayList中所有元素按序存放于参数数组中，并返回      //如果给定的参数数组长度小于ArrayList的长度，则返回一个新分配的、长度等于ArrayList长度的、包含ArrayList中所有元素的新数组### 序列化 - 写入函数writeObject(java.io.ObjectOutputStream s)- 读取函数readObject(java.io.ObjectInputStream s)### ArrayList的四种遍历方式 - 泛型在编译时会被擦除（变为Object），通过迭代器遍历获取时向下转型为源类型（泛型补偿）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/CherishFX/
      
    
    </summary>
    
    
      <category term="Java集合包" scheme="http://yoursite.com/categories/Java%E9%9B%86%E5%90%88%E5%8C%85/"/>
    
    
      <category term="源码学习" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Java集合框架" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码学习-Java集合包-集合包总结</title>
    <link href="http://yoursite.com/2020/05/23/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Java%E9%9B%86%E5%90%88%E5%8C%85-%E9%9B%86%E5%90%88%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/23/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Java%E9%9B%86%E5%90%88%E5%8C%85-%E9%9B%86%E5%90%88%E5%8C%85%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>集合是否有序</p><ul><li>有序： </li></ul></li><li><p>集合是否允许重复</p></li><li><p>是否线程安全</p></li></ol><hr><ol><li>如果读取集合中的元素 </li></ol><ul><li><p>随机访问</p></li><li><p>迭代器</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;集合是否有序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有序： &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集合是否允许重复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否线程安全&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;如果读取集合中的元素 &lt;/li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDK源码学习-Java集合包-集合包源码分析</title>
    <link href="http://yoursite.com/2020/05/23/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Java%E9%9B%86%E5%90%88%E5%8C%85-%E9%9B%86%E5%90%88%E5%8C%85%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/23/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Java%E9%9B%86%E5%90%88%E5%8C%85-%E9%9B%86%E5%90%88%E5%8C%85%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-05-23T04:49:31.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><a href="http://www.cnblogs.com/CherishFX/p/4725394.html" target="_blank" rel="noopener">参考文章— jdk1.8.0_45源码解读——ArrayList的实现</a><br><a href="http://blog.csdn.net/gulu_gulu_jp/article/details/51456969" target="_blank" rel="noopener">参考文章2—详细文字注释</a><br><a href="http://blog.csdn.net/u011392897/article/details/57105709" target="_blank" rel="noopener">参考文章3—图片分析</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">实际上java.util.ArrayList是个固定大小的对象，自身并不直接存储元素内容，而是持有一个引用&#x3D;&#x3D;element&#x3D;&#x3D;指向一个数组&#x3D;&#x3D;Object[]&#x3D;&#x3D;，真正负责存储元素内容的正是这个数组    </span><br><span class="line"></span><br><span class="line">定义了一个int值&#x3D;&#x3D;size&#x3D;&#x3D;表示数组的长度&#x3D;&#x3D;element.length&#x3D;&#x3D;    </span><br><span class="line"></span><br><span class="line">当需要扩容时，扩容的是这个数组，而不是ArrayList对象自身。(https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;48872729)</span><br><span class="line"></span><br><span class="line">- 线程不安全 modCount记录修改次数</span><br><span class="line"></span><br><span class="line">&gt; 构造函数初始化</span><br><span class="line"></span><br><span class="line">有三种构造器，原理是new一个object[]赋值给默认属性 elementData</span><br></pre></td></tr></table></figure><p>public ArrayList(int initialCapacity) //指定容量的 object[],不能小于0</p><p>public ArrayList() //默认初始化为 {}，空的数组</p><p>public ArrayList(Collection&lt;? extends E&gt; c) // </p><pre><code>&gt; 常用方法  ### 增加  - public void add(int index, E element)     往指定索引位置新增元素，确保索引没有越过上界和下界    检查长度+1后有没有超过数组  然后通过==system.arraycopy()方法==将位置为==index==的(==size-index==)个字符复制到到index+1的位置（相当于将原来的元素整体后移一位 ）- public boolean addAll(int index, Collection&lt;? extends E&gt; c)   原理跟 public void add(int index, E element)差不多，    检查增加Collection后，数组是否需要扩容      然后通过==system.arraycopy()方法==将原来从element[index]开始的size-index个元素复制到element[index+c.length]==往arraylist指向的数组中添加元素时会判断元素个数，小于10则初始化数组长度为10==- public boolean add(E e)检查元素个数+1后是否超出数组容量，超出则将数组容量增加一半（原容量右移一位）最后elementData[size++] = e- public boolean addAll(Collection&lt;? extends E&gt; c)      原理跟public boolean add(E e)差不多     获取c的长度，检查size+a.length的长度是否超过数组容量一半（原容量右移一位）==如果新增一半还不够，就新增size+c.length，不能超过int.MAX_VALUE==  最后将新增的元素复制到数组的末尾，size+=c.length### 删除- public E remove(int index)    //判断index是否 &lt;= size         //将数组elementData中index位置之后的所有元素向前移一位      //将原数组最后一个位置置为null，由GC清理- public boolean remove(Object o)   //移除ArrayList中首次出现的指定元素(如果存在)，ArrayList中允许存放重复的元素    // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。    如果要删除的元素是null，null没有equals方法，只能判断值    //私有的移除方法，跳过index参数的边界检查以及不返回任何值- protected void removeRange(int fromIndex, int toIndex)        //删除ArrayList中从fromIndex（包含）到toIndex（不包含）之间所有的元素，共移除了toIndex-fromIndex个元素- public boolean removeAll(Collection&lt;?&gt; c)     //删除ArrayList中包含在指定容器c中的所有元素        读写双指针，遍历整个数组，判断数组中元素与传入的集合中的元素是否有重合，把不包含在原集合的元素保留下来，==重合的元素删除==- public boolean retainAll(Collection&lt;?&gt; c)     //移除ArrayList中不包含在指定容器c中的所有元素，与removeAll(Collection&lt;?&gt; c)正好相反  把传入集合与原集合相同的元素保留下来，==不相同的元素删除==- public void clear()   //清空ArrayList，将全部的元素设为null### 获取- public E get(int index)   ### 修改- public E set(int index, E element)        检查索引是否越界        将旧索引值返回，旧索引指向新传入的元素### 查找元素- public boolean contains(Object o)       //遍历ArrayList，判断元素在集合中的索引值是否大于0- public int indexOf(Object o)      //正向查找，返回ArrayList中元素Object o第一次出现的位置，如果元素不存在，则返回-1- public int lastIndexOf(Object o)          //逆向查找，返回ArrayList中元素Object o最后一次出现的位置，如果元素不存在，则返回-1   - public E get(int index)       //返回指定索引处的元素### 其他public方法  - public void trimToSize()  //将底层数组的容量调整为当前列表保存的实际元素的大小的功能- public int size()     //返回ArrayList的大小（元素个数）- public boolean isEmpty()      //判断ArrayList是否为空- public Object clone()       //返回此 ArrayList实例的浅拷贝（modcount = 0）- public Object[] toArray()       //返回一个包含ArrayList中所有元素的数组- public &lt;T&gt; T[] toArray(T[] a)       //如果给定的参数数组长度足够，则将ArrayList中所有元素按序存放于参数数组中，并返回      //如果给定的参数数组长度小于ArrayList的长度，则返回一个新分配的、长度等于ArrayList长度的、包含ArrayList中所有元素的新数组### 序列化 - 写入函数writeObject(java.io.ObjectOutputStream s)- 读取函数readObject(java.io.ObjectInputStream s)### ArrayList的四种遍历方式 - 泛型在编译时会被擦除（变为Object），通过迭代器遍历获取时向下转型为源类型（泛型补偿）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/CherishFX/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>博客处女作</title>
    <link href="http://yoursite.com/2020/05/23/2017-09-05-ceshi/"/>
    <id>http://yoursite.com/2020/05/23/2017-09-05-ceshi/</id>
    <published>2020-05-23T04:49:14.000Z</published>
    <updated>2020-05-23T04:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="md-test"><a href="#md-test" class="headerlink" title="md test"></a>md test</h3><p>这是一个测试文件…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;md-test&quot;&gt;&lt;a href=&quot;#md-test&quot; class=&quot;headerlink&quot; title=&quot;md test&quot;&gt;&lt;/a&gt;md test&lt;/h3&gt;&lt;p&gt;这是一个测试文件…&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="正儿八经" scheme="http://yoursite.com/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F/"/>
    
      <category term="虾鸡八写" scheme="http://yoursite.com/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F/%E8%99%BE%E9%B8%A1%E5%85%AB%E5%86%99/"/>
    
    
      <category term="年轻人,要坚强" scheme="http://yoursite.com/tags/%E5%B9%B4%E8%BD%BB%E4%BA%BA-%E8%A6%81%E5%9D%9A%E5%BC%BA/"/>
    
      <category term="脑子里装点有用的" scheme="http://yoursite.com/tags/%E8%84%91%E5%AD%90%E9%87%8C%E8%A3%85%E7%82%B9%E6%9C%89%E7%94%A8%E7%9A%84/"/>
    
  </entry>
  
  <entry>
    <title>动态代理原理分析</title>
    <link href="http://yoursite.com/2020/05/23/Java-JVM-2017-08-30-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/05/23/Java-JVM-2017-08-30-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-23T03:44:39.000Z</published>
    <updated>2020-05-23T03:44:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理类的字节码是在程序运行期间由JVM根据反射等机制动态的生成，所以==不存在代理类的class文件==。代理类和委托类的关系是在程序运行时确定。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java 动态代理机制分析及扩展，第 1 部分</a>  </p><p><a href="http://blog.csdn.net/mhmyqn/article/details/48474815" target="_blank" rel="noopener">动态代理分析2</a></p><p><a href="http://www.cnblogs.com/MOBIN/p/5597215.html" target="_blank" rel="noopener">动态代理分析</a></p><h3 id="相关的类和接口"><a href="#相关的类和接口" class="headerlink" title="相关的类和接口"></a>相关的类和接口</h3><ul><li><p>java.lang.reflect.Proxy：<br>这是 Java 动态代理机制的主类，它提供了一组静态方法来==为一组接口动态地生成代理类及其对象==</p><ul><li><p>// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器<br>static InvocationHandler getInvocationHandler(Object proxy) </p></li><li><p>// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器==生成动态代理类实例==<br>static Object newProxyInstance(ClassLoader loader, Class[] interfaces,<br>InvocationHandler h)</p></li></ul></li><li><p>java.lang.reflect.InvocationHandler：<br>这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p><ul><li>// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象<br>// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行<br>Object invoke(Object proxy, Method method, Object[] args)</li></ul></li></ul><p>==动态代理类==与普通类的唯一区别就是其字节码是由 ==JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中==。<br>通过类装载器来进行装载才能使用</p><h3 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤"></a>具体实现步骤</h3><ol><li><p>通过实现 InvocationHandler 接口==创建自己的调用处理器==；  </p></li><li><p>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来==创建动态代理类==；</p></li><li><p>通过反射机制==获得动态代理类的构造函数==，其唯一参数类型是调用处理器接口类型；</p></li><li><p>通过构造函数==创建动态代理类实例，==构造时调用处理器对象作为参数被传入====</p></li></ol><p>实际使用过程更加简单，因为 Proxy 的静态方法 newProxyInstance 已经为我们封装了步骤 2 到步骤 4 的过程，所以简化后的过程如下    </p><ol><li><p>// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发<br>InvocationHandler handler = new InvocationHandlerImpl(..); </p></li><li><p>// 通过 Proxy 直接创建动态代理类实例<br>Interface proxy = (Interface)Proxy.newProxyInstance( classLoader,<br>new Class[] { Interface.class }, handler ); </p></li></ol><h3 id="Java-动态代理机制的一些特点。"><a href="#Java-动态代理机制的一些特点。" class="headerlink" title="Java 动态代理机制的一些特点。"></a>Java 动态代理机制的一些特点。</h3><ul><li>包：<br>如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空）<br>如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包（假设代理了 com.ibm.developerworks 包中的某非 public 接口 A，那么新生成的代理类所在的包就是 com.ibm.developerworks），<br>这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；    </li><li>类修饰符：<br>==该代理类具有 final 和 public 修饰符==，意味着它可以被所有的类访问，但是不能被再度继承；</li><li>类名：<br>格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，<br>值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，<br>这样可以节省不必要的代码重复生成，提高了代理类的创建效率。</li><li>4）类继承关系：<br>该类的继承了Proxy类、实现了一组接口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h3&gt;&lt;p&gt;动态代理类的字节码是在程序运行期间由JVM根据反射等机制动态的生成，所以==不存在代理类的class文件==。代理类和委托类
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java基础与提高" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/05/22/hello-world/"/>
    <id>http://yoursite.com/2020/05/22/hello-world/</id>
    <published>2020-05-22T15:03:10.000Z</published>
    <updated>2020-05-22T15:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
