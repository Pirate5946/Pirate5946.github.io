<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>面试整理 | Pirate5946 | coding world, coding life.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="知识整理">
  <meta name="description" content="自我介绍我叫刘涛，2015年毕业后主要从事ETL、报表开发、图表可视化展现相关的工作，参与了湖南农村信用社的 财务报表系统后期的一些开发、维护工作 2016年底作为4人开发小组的组长，主导了北京中关村银行 企业报表系统的 部署开发上线全流程，从前期项目环境搭建，需求讨论，到项目开发、流程调试，上线前项目文档验收 自己都参与了其中 2018年 参与了一个CRM项目，作为PAAS平台的元数据服务小组成">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理">
<meta property="og:url" content="http://yoursite.com/2020/05/23/interview-10-8-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Pirate5946">
<meta property="og:description" content="自我介绍我叫刘涛，2015年毕业后主要从事ETL、报表开发、图表可视化展现相关的工作，参与了湖南农村信用社的 财务报表系统后期的一些开发、维护工作 2016年底作为4人开发小组的组长，主导了北京中关村银行 企业报表系统的 部署开发上线全流程，从前期项目环境搭建，需求讨论，到项目开发、流程调试，上线前项目文档验收 自己都参与了其中 2018年 参与了一个CRM项目，作为PAAS平台的元数据服务小组成">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/ceNmtYOhbMQs4Ar4C7lr5CFmTkzO5qFP4ziaEN8O2vgic8ibP9RnGibTDcVaAxTKfTxeicpCrYquzWXRstmdviaCrSzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190111141308700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdhZGFt,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-05-23T04:49:31.000Z">
<meta property="article:modified_time" content="2020-05-23T04:49:31.000Z">
<meta property="article:author" content="Pirate5946">
<meta property="article:tag" content="知识整理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_png/ceNmtYOhbMQs4Ar4C7lr5CFmTkzO5qFP4ziaEN8O2vgic8ibP9RnGibTDcVaAxTKfTxeicpCrYquzWXRstmdviaCrSzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
  
    <link rel="alternative" href="/atom.xml" title="Pirate5946" type="application/atom+xml">
  
  <meta name="summary" content="a coder">
  <link rel="shortcut icon" href="/favicon.ico">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Pirate5946</h5>
        <a href="mailto:739686950@qq.com" title="739686950@qq.com" class="mail">739686950@qq.com</a>
      </hgroup>
    </div>
  </div>
  <div class="scroll-wrap flex-col">
    <ul class="nav">
      
          <li class="waves-block waves-effect">
            <a href="/"  >
              <i class="icon icon-lg icon-home"></i>
              主页
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/archives"  >
              <i class="icon icon-lg icon-archives"></i>
              Archives
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/tags"  >
              <i class="icon icon-lg icon-tags"></i>
              Tags
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="https://github.com/Pirate5946" target="_blank" >
              <i class="icon icon-lg icon-github"></i>
              Github
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/404"  >
              <i class="icon icon-lg icon-link"></i>
              测试
            </a>
          </li>
      
    </ul>

    <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>Pirate5946 &copy; 2020</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

  </div>
</div>

  </nav>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">面试整理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">面试整理</h1>
    <h5 class="subtitle">
        
            <time datetime="2020-05-23T04:49:31.000Z" itemprop="datePublished" class="page-time">
  2020-05-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/2020/">2020</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/2020/techframework/">techframework</a></li></ul></li></ul>

        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <article id="post-interview-10-8-高频面试题整理" 
  class="article article-type-post" itemprop="blogPost">
    <div class="post-meta flex-row">
        
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" rel="tag">知识整理</a></li></ul>

    </div>
    <div class="post-body">
        <aside class="post-widget" id="post-widget">

            
            <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

            

            
            <nav class="post-toc-wrap" id="post-toc">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#自我介绍"><span class="post-toc-number">1.</span> <span class="post-toc-text">自我介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#项目中遇到的难点"><span class="post-toc-number">2.</span> <span class="post-toc-text">项目中遇到的难点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖-前面的修改），post请求-需要保证幂等性，同时记录数据变动日志"><span class="post-toc-number">2.0.1.</span> <span class="post-toc-text">1. 多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖 前面的修改），post请求 需要保证幂等性，同时记录数据变动日志</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-在一个服务中配置两个数据源"><span class="post-toc-number">2.0.2.</span> <span class="post-toc-text">2. 在一个服务中配置两个数据源</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0-基础"><span class="post-toc-number">3.</span> <span class="post-toc-text">0 基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、java的object方法有哪些"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">1、java的object方法有哪些</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-哪些场景下，子类需要重写-equals-方法和-hashCode-方法？"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">2. 哪些场景下，子类需要重写 equals 方法和 hashCode 方法？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-列表中学生按照年龄排序"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">3. 列表中学生按照年龄排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#static-关键字使用场景，作用"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">static 关键字使用场景，作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-Java-集合"><span class="post-toc-number">4.</span> <span class="post-toc-text">1 Java 集合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-List"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">1.1 List</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ArrayList-底层数据结构"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">ArrayList 底层数据结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#add-方法逻辑"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">add 方法逻辑</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#for-foreach-循环删除list中-满足条件的对象Java-有没有问题？"><span class="post-toc-number">4.1.3.</span> <span class="post-toc-text">for&#x2F;foreach 循环删除list中 满足条件的对象Java 有没有问题？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#LinkedList"><span class="post-toc-number">4.1.4.</span> <span class="post-toc-text">LinkedList</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#add-方法"><span class="post-toc-number">4.1.4.1.</span> <span class="post-toc-text">add 方法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayList和LinkedList的区别"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">ArrayList和LinkedList的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在jvm层面，数组和链表有什么区别"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">在jvm层面，数组和链表有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashSet-、"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">HashSet 、</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">HashMap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hashMap的实现原理，链表是头插法还是尾插法"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">hashMap的实现原理，链表是头插法还是尾插法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#底层数据结构"><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">底层数据结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#put-方法流程"><span class="post-toc-number">4.6.2.</span> <span class="post-toc-text">put 方法流程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#jdk8怎么优化hashmap扩容导致的死循环问题"><span class="post-toc-number">4.6.3.</span> <span class="post-toc-text">jdk8怎么优化hashmap扩容导致的死循环问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap-和-HashTable-区别？"><span class="post-toc-number">4.6.4.</span> <span class="post-toc-text">HashMap 和 HashTable 区别？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-数据结构"><span class="post-toc-number">4.6.4.1.</span> <span class="post-toc-text">1. 数据结构</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-线程安全性"><span class="post-toc-number">4.6.4.2.</span> <span class="post-toc-text">2. 线程安全性</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为啥会线程不安全？-如何才能得到一个线程安全的HashMap？"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">为啥会线程不安全？ 如何才能得到一个线程安全的HashMap？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在数据结构上，栈和队列有什么区别"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">在数据结构上，栈和队列有什么区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#select-epoll-poll的区别"><span class="post-toc-number">5.</span> <span class="post-toc-text">select epoll,poll的区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#select"><span class="post-toc-number">5.0.1.</span> <span class="post-toc-text">select</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#poll"><span class="post-toc-number">5.0.2.</span> <span class="post-toc-text">poll</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-Java并发相关"><span class="post-toc-number">6.</span> <span class="post-toc-text">2 Java并发相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sleep-和wait-的区别"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">sleep()和wait()的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-原理篇"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">2.1 原理篇</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#比较一下-volatile-和-Synchronized"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">比较一下 volatile 和 Synchronized</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#volatile是什么，实现原理，可以实现原子性吗-线程安全吗，通过什么机制实现锁？"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">volatile是什么，实现原理，可以实现原子性吗 ,线程安全吗，通过什么机制实现锁？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#synchronized-是公平锁吗，"><span class="post-toc-number">6.2.3.</span> <span class="post-toc-text">synchronized 是公平锁吗，</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现锁的原理，获取对象的monitor-属于对象什么信息"><span class="post-toc-number">6.2.4.</span> <span class="post-toc-text">实现锁的原理，获取对象的monitor 属于对象什么信息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#自旋"><span class="post-toc-number">6.2.5.</span> <span class="post-toc-text">自旋</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JVM"><span class="post-toc-number">7.</span> <span class="post-toc-text">JVM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-怎么判断一个对象可以被回收"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">1. 怎么判断一个对象可以被回收</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-哪些对象可以作为GC-Root"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">2. 哪些对象可以作为GC Root</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-垃圾回收器，G1有什么优势"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">3. 垃圾回收器，G1有什么优势</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-jvm启动进程配置哪些参数"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">4. jvm启动进程配置哪些参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">5. 你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-堆内存4G，老年代分2-5个G-gc时间是多长"><span class="post-toc-number">7.6.</span> <span class="post-toc-text">6. 堆内存4G，老年代分2.5个G,gc时间是多长</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jvm一次完整的GC流程"><span class="post-toc-number">7.7.</span> <span class="post-toc-text">jvm一次完整的GC流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#栈内存溢出的情形（StackOverflowError-，如何解决"><span class="post-toc-number">7.8.</span> <span class="post-toc-text">栈内存溢出的情形（StackOverflowError)，如何解决</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线上oom怎么排查"><span class="post-toc-number">7.9.</span> <span class="post-toc-text">线上oom怎么排查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-JDK-工具篇"><span class="post-toc-number">7.10.</span> <span class="post-toc-text">2.2 JDK 工具篇</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-0-线程池"><span class="post-toc-number">7.10.1.</span> <span class="post-toc-text">2.2.0 线程池</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#线程池原理"><span class="post-toc-number">7.10.1.1.</span> <span class="post-toc-text">线程池原理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#线程池构造函数的参数，默认值"><span class="post-toc-number">7.10.1.2.</span> <span class="post-toc-text">线程池构造函数的参数，默认值</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#总结一下处理流程"><span class="post-toc-number">7.10.1.3.</span> <span class="post-toc-text">总结一下处理流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-2-各种锁接口-和实现类"><span class="post-toc-number">7.10.2.</span> <span class="post-toc-text">2.2.2 各种锁接口 和实现类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#可重入锁和非可重入锁"><span class="post-toc-number">7.10.2.1.</span> <span class="post-toc-text">可重入锁和非可重入锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ReentrantLock"><span class="post-toc-number">7.10.2.2.</span> <span class="post-toc-text">ReentrantLock</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#公平锁与非公平锁"><span class="post-toc-number">7.10.2.3.</span> <span class="post-toc-text">公平锁与非公平锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#读写锁和排它锁"><span class="post-toc-number">7.10.2.4.</span> <span class="post-toc-text">读写锁和排它锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#StampedLock"><span class="post-toc-number">7.10.2.5.</span> <span class="post-toc-text">StampedLock</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-3-java-同步容器、线程安全的集合"><span class="post-toc-number">7.10.3.</span> <span class="post-toc-text">2.2.3 java 同步容器、线程安全的集合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#concurrentHashMap-原理"><span class="post-toc-number">7.10.3.1.</span> <span class="post-toc-text">concurrentHashMap 原理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ConcurrentHashMap-1-7和1-8的区别、jdk8对-ConcurrentHashMap-做了哪些优化"><span class="post-toc-number">7.10.3.2.</span> <span class="post-toc-text">ConcurrentHashMap 1.7和1.8的区别、jdk8对 ConcurrentHashMap 做了哪些优化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#concurrentHashMap-怎么实现线程安全，分段锁是jdk几提出的"><span class="post-toc-number">7.10.3.3.</span> <span class="post-toc-text">concurrentHashMap 怎么实现线程安全，分段锁是jdk几提出的</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#copyOnWrite原理"><span class="post-toc-number">7.10.3.4.</span> <span class="post-toc-text">copyOnWrite原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AtomicInteger-原子类的原理、AtomicInteger-怎么实现原子性"><span class="post-toc-number">7.10.4.</span> <span class="post-toc-text">AtomicInteger 原子类的原理、AtomicInteger 怎么实现原子性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CAS实现原子操作的三大问题"><span class="post-toc-number">7.10.5.</span> <span class="post-toc-text">CAS实现原子操作的三大问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#10-5-1-ABA问题"><span class="post-toc-number">7.10.5.1.</span> <span class="post-toc-text">10.5.1 ABA问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#10-5-2-循环时间长开销大"><span class="post-toc-number">7.10.5.2.</span> <span class="post-toc-text">10.5.2 循环时间长开销大</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#10-5-3-只能保证一个共享变量的原子操作"><span class="post-toc-number">7.10.5.3.</span> <span class="post-toc-text">10.5.3 只能保证一个共享变量的原子操作</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-Mysql"><span class="post-toc-number">8.</span> <span class="post-toc-text">3 Mysql</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-sql优化的思路"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">3.1 sql优化的思路</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#InnoDB有两大类索引："><span class="post-toc-number">8.1.1.</span> <span class="post-toc-text">InnoDB有两大类索引：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#聚簇索引（clustered-index）与非聚簇索引（secondary-index）的区别-？"><span class="post-toc-number">8.1.2.</span> <span class="post-toc-text">聚簇索引（clustered index）与非聚簇索引（secondary index）的区别 ？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#回表"><span class="post-toc-number">8.1.3.</span> <span class="post-toc-text">回表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#索引覆盖"><span class="post-toc-number">8.1.4.</span> <span class="post-toc-text">索引覆盖</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-慢查询的处理方法、关注的字段（type、key、extra）"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">3.2 慢查询的处理方法、关注的字段（type、key、extra）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-事务隔离级别"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">3.3 事务隔离级别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#读未提交"><span class="post-toc-number">8.3.0.1.</span> <span class="post-toc-text">读未提交</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#读已提交"><span class="post-toc-number">8.3.0.2.</span> <span class="post-toc-text">读已提交</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#可重复读（mysql-innoDB-采用）"><span class="post-toc-number">8.3.0.3.</span> <span class="post-toc-text">可重复读（mysql innoDB 采用）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#串行读"><span class="post-toc-number">8.3.0.4.</span> <span class="post-toc-text">串行读</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-sql-使用"><span class="post-toc-number">8.3.1.</span> <span class="post-toc-text">3.4 sql 使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#对于join-和-left-join-，-on-和where的结果有没有区别"><span class="post-toc-number">8.3.2.</span> <span class="post-toc-text">对于join 和 left join ， on 和where的结果有没有区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#使用外连接（left-join-right-join）有区别"><span class="post-toc-number">8.3.2.1.</span> <span class="post-toc-text">使用外连接（left join &#x2F; right join）有区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-InnoDB与MyISAM对比"><span class="post-toc-number">8.3.3.</span> <span class="post-toc-text">3.5 InnoDB与MyISAM对比</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#innoDB怎么实现的ACID特性-、-Atomicity-原子性-Consistency-一致性-Isolation-隔离性-Transaction-持久性"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">innoDB怎么实现的ACID特性 、 Atomicity(原子性),Consistency(一致性),Isolation(隔离性),Transaction(持久性)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#innoDB支持几种锁"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">innoDB支持几种锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#innoDB的标准行级锁有哪两种"><span class="post-toc-number">8.6.</span> <span class="post-toc-text">innoDB的标准行级锁有哪两种</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-树叶子节点存的是什么"><span class="post-toc-number">8.7.</span> <span class="post-toc-text">B+树叶子节点存的是什么</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-Spring"><span class="post-toc-number">9.</span> <span class="post-toc-text">4 Spring</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#spring-和-spring-boot的区别"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">spring 和 spring boot的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四种方式配置Bean"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">四种方式配置Bean</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#IOC"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">IOC</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#扫描注解定义的Bean"><span class="post-toc-number">9.3.1.</span> <span class="post-toc-text">扫描注解定义的Bean</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#自动装配Bean"><span class="post-toc-number">9.3.2.</span> <span class="post-toc-text">自动装配Bean</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#延迟依赖注入"><span class="post-toc-number">9.3.2.1.</span> <span class="post-toc-text">延迟依赖注入</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Bean的作用范围、生命过程"><span class="post-toc-number">9.3.3.</span> <span class="post-toc-text">Bean的作用范围、生命过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基于Java-类的配置-Configuration"><span class="post-toc-number">9.3.4.</span> <span class="post-toc-text">基于Java 类的配置  @Configuration</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用基于-Java类的配置信息-启动Spring容器"><span class="post-toc-number">9.3.5.</span> <span class="post-toc-text">使用基于 Java类的配置信息 启动Spring容器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通过编码方式动态添加-Bean"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">通过编码方式动态添加 Bean</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过DefaultListableBeanFactory"><span class="post-toc-number">9.4.1.</span> <span class="post-toc-text">通过DefaultListableBeanFactory</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AOP的原理、应用"><span class="post-toc-number">9.5.</span> <span class="post-toc-text">AOP的原理、应用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Spring如何选择两种代理模式的？"><span class="post-toc-number">9.6.</span> <span class="post-toc-text">Spring如何选择两种代理模式的？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-2-Spring-事务"><span class="post-toc-number">9.6.1.</span> <span class="post-toc-text">4.2 Spring 事务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#事务同步管理器"><span class="post-toc-number">9.6.1.1.</span> <span class="post-toc-text">事务同步管理器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Spring事务的实现原理，嵌套事务的实现原理"><span class="post-toc-number">9.6.1.2.</span> <span class="post-toc-text">Spring事务的实现原理，嵌套事务的实现原理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#回滚设置"><span class="post-toc-number">9.6.1.3.</span> <span class="post-toc-text">回滚设置</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Transaction-应用位置"><span class="post-toc-number">9.6.1.4.</span> <span class="post-toc-text">@Transaction 应用位置</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ThreadLocal"><span class="post-toc-number">9.6.1.5.</span> <span class="post-toc-text">ThreadLocal</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Spring事务的隔离级别？-默认值？"><span class="post-toc-number">9.6.1.6.</span> <span class="post-toc-text">Spring事务的隔离级别？ 默认值？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Spring事务的传播属性？-默认值？"><span class="post-toc-number">9.6.1.7.</span> <span class="post-toc-text">Spring事务的传播属性？ 默认值？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#spring-事务不生效-Transactional注解无效-的场景"><span class="post-toc-number">9.6.1.8.</span> <span class="post-toc-text">spring 事务不生效(@Transactional注解无效)的场景</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SpringBoot-自动装配的原理"><span class="post-toc-number">9.7.</span> <span class="post-toc-text">SpringBoot 自动装配的原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#springboot的启动流程"><span class="post-toc-number">9.8.</span> <span class="post-toc-text">springboot的启动流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-Mybatis"><span class="post-toc-number">10.</span> <span class="post-toc-text">5 Mybatis</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-为什么要用-mybatis-这种持久层框架？"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">1. 为什么要用 mybatis 这种持久层框架？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-自己怎么实现mybatis，实现原理"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">2. 自己怎么实现mybatis，实现原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-mybatis-一二级缓存配置"><span class="post-toc-number">10.3.</span> <span class="post-toc-text">3. mybatis 一二级缓存配置</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-Rabbit-MQ"><span class="post-toc-number">11.</span> <span class="post-toc-text">6 Rabbit MQ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Rabbit-MQ-架构设计"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">Rabbit MQ 架构设计</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如果-Rabbit-MQ-挂掉了，后续流程怎么处理"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">如果 Rabbit MQ 挂掉了，后续流程怎么处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#消息持久化"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">消息持久化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Rabbit-MQ-如何保证消息正确投递"><span class="post-toc-number">11.4.</span> <span class="post-toc-text">Rabbit MQ 如何保证消息正确投递</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1、生产者丢数据"><span class="post-toc-number">11.4.0.1.</span> <span class="post-toc-text">1、生产者丢数据</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2、消息队列丢数据"><span class="post-toc-number">11.4.0.2.</span> <span class="post-toc-text">2、消息队列丢数据</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3、消费者丢数据"><span class="post-toc-number">11.4.0.3.</span> <span class="post-toc-text">3、消费者丢数据</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何保证消息不被重复消费？"><span class="post-toc-number">11.5.</span> <span class="post-toc-text">如何保证消息不被重复消费？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#造成重复消费的原因"><span class="post-toc-number">11.5.1.</span> <span class="post-toc-text">造成重复消费的原因?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#针对业务场景来答分以下几点"><span class="post-toc-number">11.5.2.</span> <span class="post-toc-text">针对业务场景来答分以下几点</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何保证消息的顺序性？"><span class="post-toc-number">11.6.</span> <span class="post-toc-text">如何保证消息的顺序性？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-Redis"><span class="post-toc-number">12.</span> <span class="post-toc-text">7 Redis</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么单线程更加快"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">为什么单线程更加快</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#"><span class="post-toc-number">12.1.1.</span> <span class="post-toc-text"></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#持久化方案"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">持久化方案</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#快照模式（RDB）"><span class="post-toc-number">12.2.1.</span> <span class="post-toc-text">快照模式（RDB）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AOF（Append-Only-File）-模式"><span class="post-toc-number">12.2.2.</span> <span class="post-toc-text">AOF（Append Only File） 模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主从配置、哨兵模式，集群模式"><span class="post-toc-number">12.3.</span> <span class="post-toc-text">主从配置、哨兵模式，集群模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#更换故障主服务器"><span class="post-toc-number">12.3.1.</span> <span class="post-toc-text">更换故障主服务器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#方法一：升级当前从服务器为主服务器"><span class="post-toc-number">12.3.1.1.</span> <span class="post-toc-text">方法一：升级当前从服务器为主服务器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#方法二"><span class="post-toc-number">12.3.1.2.</span> <span class="post-toc-text">方法二</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#redis集群是如何同步数据的？"><span class="post-toc-number">12.3.2.</span> <span class="post-toc-text">redis集群是如何同步数据的？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Redis复制过程"><span class="post-toc-number">12.3.3.</span> <span class="post-toc-text">Redis复制过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#哨兵模式-Redis-Sentinel"><span class="post-toc-number">12.3.4.</span> <span class="post-toc-text">哨兵模式 Redis Sentinel</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#缓存雪崩和失效的场景"><span class="post-toc-number">12.4.</span> <span class="post-toc-text">缓存雪崩和失效的场景</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-SpringCloud-中间件"><span class="post-toc-number">13.</span> <span class="post-toc-text">8 SpringCloud 中间件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#服务注册、服务发现-Eureka"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">服务注册、服务发现 Eureka</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Http客户端-Feign"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">Http客户端 Feign</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Feign设置超时时间"><span class="post-toc-number">13.2.1.</span> <span class="post-toc-text">Feign设置超时时间</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#负载均衡-ribbon、"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">负载均衡 ribbon、</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#服务降级-Hystrix"><span class="post-toc-number">13.4.</span> <span class="post-toc-text">服务降级 Hystrix</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-Zookeeper"><span class="post-toc-number">14.</span> <span class="post-toc-text">9 Zookeeper</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#几个重要的-父znode"><span class="post-toc-number">14.0.1.</span> <span class="post-toc-text">几个重要的 父znode</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#zookeeper-实现分布式锁"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">zookeeper 实现分布式锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在主节点上增加监视点"><span class="post-toc-number">14.1.1.</span> <span class="post-toc-text">在主节点上增加监视点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#设置-子节点的监视点"><span class="post-toc-number">14.1.2.</span> <span class="post-toc-text">设置 子节点的监视点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Zookeeper一致性协议原理Zab-，ZAB（ZooKeeper-Atomic-Broadcast-）-全称为：原子消息广播协议"><span class="post-toc-number">14.1.3.</span> <span class="post-toc-text">Zookeeper一致性协议原理Zab ，ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ZAB协议的两个基本模式：恢复模式和广播模式"><span class="post-toc-number">14.1.3.1.</span> <span class="post-toc-text">ZAB协议的两个基本模式：恢复模式和广播模式</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#设计模式"><span class="post-toc-number">15.</span> <span class="post-toc-text">设计模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用过的设计模式有哪些"><span class="post-toc-number">15.1.</span> <span class="post-toc-text">用过的设计模式有哪些</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-性能优化"><span class="post-toc-number">16.</span> <span class="post-toc-text">10 性能优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线上oom怎么排查-1"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">线上oom怎么排查</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如果一个-前端请求查询耗时很长，怎么优化"><span class="post-toc-number">16.1.1.</span> <span class="post-toc-text">如果一个 前端请求查询耗时很长，怎么优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#nginx中的超时设置，请求超时、响应等待超时等"><span class="post-toc-number">16.1.2.</span> <span class="post-toc-text">nginx中的超时设置，请求超时、响应等待超时等</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#其他"><span class="post-toc-number">17.</span> <span class="post-toc-text">其他</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从1000w个数字中找出最小的10个并打印"><span class="post-toc-number">17.0.1.</span> <span class="post-toc-text">从1000w个数字中找出最小的10个并打印</span></a></li></ol></li></ol></li></ol>
            </nav>
            
        </aside>

        <div class="post-main">

            <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫刘涛，2015年毕业后主要从事ETL、报表开发、图表可视化展现相关的工作，<br>参与了湖南农村信用社的 财务报表系统后期的一些开发、维护工作</p>
<p>2016年底作为4人开发小组的组长，主导了北京中关村银行 企业报表系统的 部署开发上线全流程，<br>从前期项目环境搭建，需求讨论，到项目开发、流程调试，<br>上线前项目文档验收 自己都参与了其中</p>
<p>2018年 参与了一个CRM项目，<br>作为PAAS平台的元数据服务小组成员，主要负责元数据服务的原有功能维护 和<br>新业务功能的扩展，包括对公司其他业务线和公司的合作伙伴提供rest接口，</p>
<p>另外也有配合中间件小组 对元数据服务进行一些技术栈升级，<br>比如替换ID生成器，替换消息队列（kestrel转rabbit MQ）</p>
<p>2019年全年参与了一个机票代理平台的4.0版本迭代，项目于2020年元旦成功上线<br>自己作为项目核心开发成员，主要负责订单服务，政策服务，基础数据服务的后端功能开发<br>和部分前台页面开发，</p>
<p>对于微服务环境部署、服务拆分工作也有涉及</p>
<p>希望接下来继续从事Java服务端开发的工作</p>
<h2 id="项目中遇到的难点"><a href="#项目中遇到的难点" class="headerlink" title="项目中遇到的难点"></a>项目中遇到的难点</h2><h4 id="1-多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖-前面的修改），post请求-需要保证幂等性，同时记录数据变动日志"><a href="#1-多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖-前面的修改），post请求-需要保证幂等性，同时记录数据变动日志" class="headerlink" title="1. 多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖 前面的修改），post请求 需要保证幂等性，同时记录数据变动日志"></a>1. 多人同时维护基础数据时（改的不是同一项数据，后提交的修改覆盖 前面的修改），post请求 需要保证幂等性，同时记录数据变动日志</h4><ol>
<li>拦截修改前的查询请求，根据请求生成页面版本号，在redis中缓存版本号和实体信息           </li>
<li>拦截修改请求，比对版本号，通过后比较实体修改前后的信息，记录操作日志</li>
<li>通过消息队列 解耦日志服务的后续操作 （新旧实体比较 和入库）</li>
</ol>
<h4 id="2-在一个服务中配置两个数据源"><a href="#2-在一个服务中配置两个数据源" class="headerlink" title="2. 在一个服务中配置两个数据源"></a>2. 在一个服务中配置两个数据源</h4><ol>
<li><p>AOP拦截指定请求，通过ThreadLocal 设置当前线程数据源</p>
</li>
<li><p>继承 AbstractRoutingDataSource 重写 determineCurrentLookupKey 方法 获取当前线程数据源 </p>
</li>
</ol>
<h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0 基础"></a>0 基础</h2><h3 id="1、java的object方法有哪些"><a href="#1、java的object方法有哪些" class="headerlink" title="1、java的object方法有哪些"></a>1、java的object方法有哪些</h3><ul>
<li>hashcode、equals</li>
<li>getClass</li>
<li>toString</li>
<li>notify、notifyAll</li>
<li>wait</li>
<li>clone</li>
<li>finalize</li>
</ul>
<h3 id="2-哪些场景下，子类需要重写-equals-方法和-hashCode-方法？"><a href="#2-哪些场景下，子类需要重写-equals-方法和-hashCode-方法？" class="headerlink" title="2. 哪些场景下，子类需要重写 equals 方法和 hashCode 方法？"></a>2. 哪些场景下，子类需要重写 equals 方法和 hashCode 方法？</h3><p>Object的equals只比较了对象的引用地址，重写equals()是为了实现自己的区分逻辑，</p>
<p>==如果重写的equals()方法确定了两个对象相等，则这两个对象的hashCode必须返回相同的值==<br>，Object的hashCode是一个native本地方法，所以必须重写    </p>
<p>重写hashCode()是为了提高hash tables的使用效率，<br>如果equals()方法确定了两个对象不相等，这个两个对象的hashCode还是有可能相等的。<br>但是不同的对象应该有着不同的hashCode，这样可以提高hash tables的使用效率。</p>
<p>对于equals不相同而hashCode相同的元素集合，在哈希表中会以链表或者红黑树的形式储存</p>
<h3 id="3-列表中学生按照年龄排序"><a href="#3-列表中学生按照年龄排序" class="headerlink" title="3. 列表中学生按照年龄排序"></a>3. 列表中学生按照年龄排序</h3><p>重写compareTo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 升序 </span></span><br><span class="line">       <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">       <span class="comment">// 降序</span></span><br><span class="line">       <span class="comment">// return o2.getAge().compareTo(o1.getAge());</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="static-关键字使用场景，作用"><a href="#static-关键字使用场景，作用" class="headerlink" title="static 关键字使用场景，作用"></a>static 关键字使用场景，作用</h3><p>只存在一份引用，放在方法区，所有线程共享</p>
<hr>
<h2 id="1-Java-集合"><a href="#1-Java-集合" class="headerlink" title="1 Java 集合"></a>1 Java 集合</h2><h3 id="1-1-List"><a href="#1-1-List" class="headerlink" title="1.1 List"></a>1.1 List</h3><p>支持按索引访问，存入和取出顺序不变，元素可重复，可以保存null值   </p>
<h4 id="ArrayList-底层数据结构"><a href="#ArrayList-底层数据结构" class="headerlink" title="ArrayList 底层数据结构"></a>ArrayList 底层数据结构</h4><p>Object数组，</p>
<h4 id="add-方法逻辑"><a href="#add-方法逻辑" class="headerlink" title="add 方法逻辑"></a>add 方法逻辑</h4><p>1、 检查是否需要扩容<br>新的长度不长于 MAX_ARRAY_SIZE 时，增长为原长度的1.5倍，否则赋值为 MAX_ARRAY_SIZE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line"></span><br><span class="line">elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure>
<p>2、 在末尾添加元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[size++] = e;</span><br></pre></td></tr></table></figure>

<h4 id="for-foreach-循环删除list中-满足条件的对象Java-有没有问题？"><a href="#for-foreach-循环删除list中-满足条件的对象Java-有没有问题？" class="headerlink" title="for/foreach 循环删除list中 满足条件的对象Java 有没有问题？"></a>for/foreach 循环删除list中 满足条件的对象Java 有没有问题？</h4><p>有问题，快速失败机制，会抛出异常 <a href="https://my.oschina.net/hosee/blog/612718" target="_blank" rel="noopener">ConcurrentModificationException的原因以及解决措施</a></p>
<p>单线程解决方案：使用 迭代器的remove方法</p>
<p>多线程 两种解决方案：     </p>
<ol>
<li><p>在使用iterator迭代的时候使用synchronized或者Lock进行同步；（一个个迭代就和单线程一样了）</p>
</li>
<li><p>使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</p>
</li>
</ol>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>双向列表，增删快</p>
<h5 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><p>数据结构不同，使用场景不同</p>
<h3 id="在jvm层面，数组和链表有什么区别"><a href="#在jvm层面，数组和链表有什么区别" class="headerlink" title="在jvm层面，数组和链表有什么区别"></a>在jvm层面，数组和链表有什么区别</h3><p>不太清除</p>
<h3 id="HashSet-、"><a href="#HashSet-、" class="headerlink" title="HashSet 、"></a>HashSet 、</h3><p>内部持有 HashMap引用， key 可以为 null, 不能重复</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="hashMap的实现原理，链表是头插法还是尾插法"><a href="#hashMap的实现原理，链表是头插法还是尾插法" class="headerlink" title="hashMap的实现原理，链表是头插法还是尾插法"></a>hashMap的实现原理，链表是头插法还是尾插法</h3><p>1.8 之前是头插法、1.8是尾插法</p>
<h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>数组 + 链表 （长度超过 8 转换成红黑树）</p>
<h4 id="put-方法流程"><a href="#put-方法流程" class="headerlink" title="put 方法流程"></a>put 方法流程</h4><p>1、 初始化第一次调用 put，<br>根据初始化给的初始容量（会向上调整为2的n次幂），初始化 hash表（Node&lt;K,V&gt;[] table）</p>
<p>2、 根据 key的 hash值取模，获取key在 hash表（Node数组）中的存放位置，<br>取模方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<p>如果当前索引位置没有值，在当前位置初始化 Node     </p>
<p>如果当前索引位置有值（hash冲突），     </p>
<ul>
<li>如果是重复的key，用新值替换旧值，返回旧值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure></li>
<li>遍历查看当前节点的下一节点，直到找到重复的key，用新值替换旧值，返回旧值；<br>或者找到null节点，在当前位置初始化 Node，<br>如果链表的长度 &gt;= 8 并且hash表长度大于64，将当前列表转换成红黑树，否则reHash()     </li>
</ul>
<p>3、 modCount 记录修改次数 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>4、 当前 Node数量自增1 ，与当前阈值比较，判断是否需要扩容</p>
<h4 id="jdk8怎么优化hashmap扩容导致的死循环问题"><a href="#jdk8怎么优化hashmap扩容导致的死循环问题" class="headerlink" title="jdk8怎么优化hashmap扩容导致的死循环问题"></a>jdk8怎么优化hashmap扩容导致的死循环问题</h4><p>JDK7 线程扩容时的搬运结点操作 为了提高效率采用的头插法 导致线程之间 看到了错误的next指向，导致成环，       </p>
<p>JDK8采用尾插法（尾插法一是用于避免死循环，二是根据槽中个数判断是否需要树化）修复了此问题，但是由于是线程不安全的，还会有别的并发问题发生</p>
<h4 id="HashMap-和-HashTable-区别？"><a href="#HashMap-和-HashTable-区别？" class="headerlink" title="HashMap 和 HashTable 区别？"></a>HashMap 和 HashTable 区别？</h4><h5 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h5><p>HashTable : 数组 + 链表</p>
<p>HashMap ： 数组 + 链表 （长度超过 8 转换成红黑树）</p>
<p>Hashtable中，key和value都不允许出现null值。        </p>
<p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null，<br>在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用 containsKey()方法来判断。</p>
<h5 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h5><p>HashTable : 线程安全 ， Synchronized 修饰方法，当前实例被锁住，只能串行调用其他方法</p>
<p>HashMap ： 线程不安全</p>
<h3 id="为啥会线程不安全？-如何才能得到一个线程安全的HashMap？"><a href="#为啥会线程不安全？-如何才能得到一个线程安全的HashMap？" class="headerlink" title="为啥会线程不安全？ 如何才能得到一个线程安全的HashMap？"></a>为啥会线程不安全？ 如何才能得到一个线程安全的HashMap？</h3><p>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p>
<p>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p>
<p>put/get方法都没有加同步锁，多线程情况最容易出现的就是：<br>无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</p>
<p>使用 ConcurrentHashMap、 或者 Collections.synchronizedMap()</p>
<h3 id="在数据结构上，栈和队列有什么区别"><a href="#在数据结构上，栈和队列有什么区别" class="headerlink" title="在数据结构上，栈和队列有什么区别"></a>在数据结构上，栈和队列有什么区别</h3><p>队列是先进先出，新来的成员总是加入队尾</p>
<p>栈是先进后出，继承了Vector，线程安全，栈只能从顶部取数据</p>
<hr>
<h2 id="select-epoll-poll的区别"><a href="#select-epoll-poll的区别" class="headerlink" title="select epoll,poll的区别"></a>select epoll,poll的区别</h2><p>select，poll，epoll都是IO多路复用的机制，</p>
<p>IO多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>不停的调用poll,直到有需要的消息为止，最大连接数 1024</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>没有连接上限</p>
<p>select, poll是为了解決同时大量IO的情況（尤其网络服务器），但是随着连接数越多，性能越差</p>
<p>epoll是select和poll的改进方案，在 linux 上可以取代 select 和 poll，可以处理大量连接的性能问题</p>
<h2 id="2-Java并发相关"><a href="#2-Java并发相关" class="headerlink" title="2 Java并发相关"></a>2 Java并发相关</h2><p>定义： 多个线程读写 可变的共享资源 时，跟单个线程操作结果一致</p>
<h3 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h3><ol>
<li>wait可以指定时间，也可以不指定；而sleep必须指定时间。</li>
<li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。</li>
<li>wait必须放在同步块或同步方法中，而sleep可以在任意位置</li>
</ol>
<h3 id="2-1-原理篇"><a href="#2-1-原理篇" class="headerlink" title="2.1 原理篇"></a>2.1 原理篇</h3><h4 id="比较一下-volatile-和-Synchronized"><a href="#比较一下-volatile-和-Synchronized" class="headerlink" title="比较一下 volatile 和 Synchronized"></a>比较一下 volatile 和 Synchronized</h4><p>volatile 修饰变量，可以保证 线程之间共享资源 的 可见性、有序性</p>
<p>Synchronized 可以修改代码块，方法，类 ；可以保证 被它修饰的方法或者代码块在任意时刻只能有一个线程执行</p>
<h4 id="volatile是什么，实现原理，可以实现原子性吗-线程安全吗，通过什么机制实现锁？"><a href="#volatile是什么，实现原理，可以实现原子性吗-线程安全吗，通过什么机制实现锁？" class="headerlink" title="volatile是什么，实现原理，可以实现原子性吗 ,线程安全吗，通过什么机制实现锁？"></a>volatile是什么，实现原理，可以实现原子性吗 ,线程安全吗，通过什么机制实现锁？</h4><p>volatile是通过编译器在生成字节码时，在指令序列中添加“内存屏障”来禁止指令重排序</p>
<p>在Java多线程情况下，volatile修饰的变量可以保证线程可见性且提供了一定的有序性，不能保证原子性，</p>
<p>不能保证线程安全，比如 i++</p>
<p>通过CAS机制实现线程安全，在Java中Unsafe对CAS进行了封装</p>
<h4 id="synchronized-是公平锁吗，"><a href="#synchronized-是公平锁吗，" class="headerlink" title="synchronized 是公平锁吗，"></a>synchronized 是公平锁吗，</h4><p>非公平锁， synchronized 获取不到锁的时候，会自动加入队列，等待线程释放锁后所有等待的线程同时去竞争</p>
<p>可重入</p>
<p>悲观锁</p>
<h4 id="实现锁的原理，获取对象的monitor-属于对象什么信息"><a href="#实现锁的原理，获取对象的monitor-属于对象什么信息" class="headerlink" title="实现锁的原理，获取对象的monitor 属于对象什么信息"></a>实现锁的原理，获取对象的monitor 属于对象什么信息</h4><p>同步代码块是使用 monitorenter 和 monitorexit 指令实现的</p>
<p>synchronized方法，在Class文件的方法表中将该方法的accessflags字段中的synchronized标志位置1</p>
<p>Java的锁都是基于对象的，对象的“锁”的信息是存放在对象头的Mark Word</p>
<p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“</p>
<p>当对象状态为偏向锁时，Mark Word存储的是偏向的线程ID；<br>当状态为轻量级锁时，Mark Word存储的是指向线程栈中Lock Record的指针；<br>当状态为重量级锁时，Mark Word为指向堆中的monitor对象的指针</p>
<h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起（就是不让前来获取该锁（已被占用）的线程立即阻塞），看持有锁的线程是否会很快释放锁。</p>
<p>怎么等待呢？</p>
<p>执行一段无意义的循环即可（自旋）</p>
<p>避免CPU从用户态转为核心态，频繁的阻塞和唤醒</p>
<p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁，线程如果自旋成功了，那么下次自旋的次数会更加多</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-怎么判断一个对象可以被回收"><a href="#1-怎么判断一个对象可以被回收" class="headerlink" title="1. 怎么判断一个对象可以被回收"></a>1. 怎么判断一个对象可以被回收</h3><p>可达性分析 ： 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链时，则认为此对象可以被回收</p>
<h3 id="2-哪些对象可以作为GC-Root"><a href="#2-哪些对象可以作为GC-Root" class="headerlink" title="2. 哪些对象可以作为GC Root"></a>2. 哪些对象可以作为GC Root</h3><p>方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,</p>
<p>a.虚拟机栈(栈桢中的本地变量表)中的引用的对象<br>b.方法区中的类静态属性引用的对象<br>c.方法区中的常量引用的对象<br>d.本地方法栈中JNI的引用的对象       </p>
<h3 id="3-垃圾回收器，G1有什么优势"><a href="#3-垃圾回收器，G1有什么优势" class="headerlink" title="3. 垃圾回收器，G1有什么优势"></a>3. 垃圾回收器，G1有什么优势</h3><p>G1的设计原则就是简单可行的性能调优，</p>
<p>主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，尽可能的满足垃圾回收时的暂停时间</p>
<p>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念</p>
<p>G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</p>
<h3 id="4-jvm启动进程配置哪些参数"><a href="#4-jvm启动进程配置哪些参数" class="headerlink" title="4. jvm启动进程配置哪些参数"></a>4. jvm启动进程配置哪些参数</h3><p> nohup java -server -Duser.timezone=GMT+08 -Xmx1g -Xms1g<br> -XX:NewRatio=4 -XX:SurvivorRatio=8<br> -XX:PermSize=64m -XX:MaxPermSize=128m -Xss512k<br> -XX:ThreadStackSize=128k -XX:MaxDirectMemorySize=256m<br> -XX:-ReduceInitialCardMarks -XX:+PrintGCDetails<br> -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/LOGS/applogs/jvm-log/web-gc.log<br> -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled<br> -XX:ParallelCMSThreads=4 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection<br> -XX:CMSInitiatingOccupancyFraction=50 -XX:CMSFullGCsBeforeCompaction=2 -XX:+UseCompressedOops<br> -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/LOGS/applogs/jvm-dump/web_heapDump.hprof<br> -Dcom.sun.management.jmxremote=true -Djava.rmi.server.hostname=192.168.1.221<br> -Dcom.sun.management.jmxremote.port=28081 -Dcom.sun.management.jmxremote.ssl=false<br> -Dcom.sun.management.jmxremote.authenticate=false -XX:+UnlockCommercialFeatures -XX:+FlightRecorder<br> -jar bs4-web-0.0.1-SNAPSHOT.jar &gt;&gt;/LOGS/applogs/bs4-web.log 2&gt;&amp;1 &amp;</p>
<h3 id="5-你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置"><a href="#5-你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置" class="headerlink" title="5. 你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置"></a>5. 你们jvm垃圾回收新生代、老年代怎么配置的，为什么这样配置</h3><p>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆内存的1/5</p>
<p>1.追求响应时间优先</p>
<p>这种需求下，新生代尽可能设置大一些，因为新生代比较大，发生垃圾回收的频率会比较低，响应时间快速。</p>
<p>老年代空间不足发生Full GC</p>
<h3 id="6-堆内存4G，老年代分2-5个G-gc时间是多长"><a href="#6-堆内存4G，老年代分2-5个G-gc时间是多长" class="headerlink" title="6. 堆内存4G，老年代分2.5个G,gc时间是多长"></a>6. 堆内存4G，老年代分2.5个G,gc时间是多长</h3><p>不知道</p>
<h3 id="jvm一次完整的GC流程"><a href="#jvm一次完整的GC流程" class="headerlink" title="jvm一次完整的GC流程"></a>jvm一次完整的GC流程</h3><p>当 Eden 区没有足够空间时，会发起一次 Minor GC；清理不可达的对象</p>
<p>存活的对象，年龄+1，一定次数后进入老年代，老年代空间不够时，进行full gc，Full GC 尽量避免</p>
<h3 id="栈内存溢出的情形（StackOverflowError-，如何解决"><a href="#栈内存溢出的情形（StackOverflowError-，如何解决" class="headerlink" title="栈内存溢出的情形（StackOverflowError)，如何解决"></a>栈内存溢出的情形（StackOverflowError)，如何解决</h3><p>1、递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p>
<p>2、方法内声明了海量的局部变量，局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。</p>
<p>解决方案：</p>
<ol>
<li><p>修复引发无限递归调用的异常代码,        </p>
</li>
<li><p>通过 JVM 启动参数 -Xss 增加线程栈内存空间， 某些正常使用场景需要执行大量方法或包含大量局部变量，这时可以适当地提高线程栈空间限制</p>
</li>
</ol>
<h3 id="线上oom怎么排查"><a href="#线上oom怎么排查" class="headerlink" title="线上oom怎么排查"></a>线上oom怎么排查</h3><p>查看日志、分析dump文件，查看占用内存较多的对象</p>
<ol>
<li><p>ps -aux|grep java 当服务重新部署后，可以找出当前Java进程的PID</p>
</li>
<li><p>jstat -gcutil pid interval 用于查看当前GC的状态,它对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控</p>
</li>
<li><p>jmap -histo:live pid 可用统计存活对象的分布情况，从高到低查看占据内存最多的对象。上图</p>
</li>
<li><p>分析dump文件</p>
</li>
</ol>
<hr>
<h3 id="2-2-JDK-工具篇"><a href="#2-2-JDK-工具篇" class="headerlink" title="2.2 JDK 工具篇"></a>2.2 JDK 工具篇</h3><h4 id="2-2-0-线程池"><a href="#2-2-0-线程池" class="headerlink" title="2.2.0 线程池"></a><a href="http://concurrent.redspider.group/article/03/12.html" target="_blank" rel="noopener">2.2.0 线程池</a></h4><p>线程池顶层接口是Executor接口，ThreadPoolExecutor 是这个接口的实现类</p>
<h5 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h5><p>使用线程池主要有以下三个原因：</p>
<ul>
<li>控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li>
<li>创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。</li>
<li>可以对线程做统一管理 (传入 ThreadFactory ，设置线程池名称 、线程优先级、是否为守护线程)</li>
</ul>
<p>ThreadPoolExecutor在创建线程时，会将线程封装成工作线程worker,并放入工作线程组中，<br>然后这个worker反复从阻塞队列中拿任务去执行。</p>
<h5 id="线程池构造函数的参数，默认值"><a href="#线程池构造函数的参数，默认值" class="headerlink" title="线程池构造函数的参数，默认值"></a>线程池构造函数的参数，默认值</h5><p>涉及到5~7个参数，必须的5个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int corePoolSize：该线程池中核心线程数最大值</span><br><span class="line"></span><br><span class="line">    核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</span><br><span class="line"></span><br><span class="line">int maximumPoolSize：该线程池中线程总数最大值 。</span><br><span class="line"></span><br><span class="line">    该值等于核心线程数量 + 非核心线程数量。</span><br><span class="line"></span><br><span class="line">long keepAliveTime：非核心线程闲置超时时长。</span><br><span class="line"></span><br><span class="line">    非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</span><br><span class="line"></span><br><span class="line">TimeUnit unit：keepAliveTime的单位。</span><br><span class="line"></span><br><span class="line">    TimeUnit是一个枚举类型 ，包括以下属性：</span><br><span class="line">    </span><br><span class="line">    NANOSECONDS ： 1微毫秒 &#x3D; 1微秒 &#x2F; 1000 MICROSECONDS ： 1微秒 &#x3D; 1毫秒 &#x2F; 1000 MILLISECONDS ： 1毫秒 &#x3D; 1秒 &#x2F;1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天</span><br><span class="line">    </span><br><span class="line">BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象。</span><br><span class="line"></span><br><span class="line">    常用的几个阻塞队列：</span><br><span class="line">    </span><br><span class="line">    LinkedBlockingQueue</span><br><span class="line">    </span><br><span class="line">    链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。</span><br><span class="line">    </span><br><span class="line">    ArrayBlockingQueue</span><br><span class="line">    </span><br><span class="line">    数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</span><br><span class="line">    </span><br><span class="line">    SynchronousQueue</span><br><span class="line">    </span><br><span class="line">    同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</span><br><span class="line">    </span><br><span class="line">    DelayQueue</span><br><span class="line">    </span><br><span class="line">    延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素</span><br></pre></td></tr></table></figure>

<p>两个非必须的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory</span><br><span class="line"></span><br><span class="line">    创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂     </span><br><span class="line"></span><br><span class="line">RejectedExecutionHandler handler</span><br><span class="line"></span><br><span class="line">    拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</span><br></pre></td></tr></table></figure>

<h5 id="总结一下处理流程"><a href="#总结一下处理流程" class="headerlink" title="总结一下处理流程"></a>总结一下处理流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. 线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。注意，这一步需要获得全局锁。</span><br><span class="line">2. 线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。</span><br><span class="line">3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。</span><br><span class="line">4. 缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，       </span><br><span class="line">在while循环中，worker会不断地调用getTask方法从阻塞队列中获取任务然后调用task.run()执行任务,从而达到复用线程的目的。只要getTask方法不返回null,此线程就不会退出。</span><br><span class="line"></span><br><span class="line">核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果STOP或者TERMINATED，返回null</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">##### prestartAllCoreThreads 启动所有核心线程</span><br><span class="line"></span><br><span class="line">#####  线程池 拒绝策略有哪些</span><br><span class="line">RejectedExecutionHandler handler</span><br><span class="line"></span><br><span class="line">拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;ThreadPoolExecutor.AbortPolicy&#x3D;&#x3D;：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程(任务所属线程)处理该任务</span><br><span class="line"></span><br><span class="line">#### 2.2.1 线程池 阻塞队列 （CLH） 原理</span><br><span class="line">常用的几个阻塞队列：</span><br><span class="line">&#96;&#96;&#96;text</span><br><span class="line">LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。</span><br><span class="line"></span><br><span class="line">ArrayBlockingQueue</span><br><span class="line"></span><br><span class="line">数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</span><br><span class="line"></span><br><span class="line">SynchronousQueue</span><br><span class="line"></span><br><span class="line">同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</span><br><span class="line"></span><br><span class="line">DelayQueue</span><br><span class="line"></span><br><span class="line">延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-各种锁接口-和实现类"><a href="#2-2-2-各种锁接口-和实现类" class="headerlink" title="2.2.2 各种锁接口 和实现类"></a>2.2.2 各种锁接口 和实现类</h4><h5 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h5><p>重入锁的概念 ；        </p>
<p>支持同一个线程对资源重复加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;  作为重入计数器</span><br></pre></td></tr></table></figure>
<p>ReentrantLock 的中文意思就是可重入锁。</p>
<p>synchronized关键字就是使用的重入锁。<br>在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常</p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>内部有一个抽象类Sync，是继承了AQS,<br>还有两个非抽象类NonfairSync和FairSync，它们都继承了Sync，都是独占式的排它锁</p>
<p>ReentrantLock支持非公平锁和公平锁两种。</p>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>公平锁 ： FIFO, 先对锁获取请求的线程先被满足，后对锁获取请求的线程后被满足</p>
<p>而非公平锁新入的线程则可以先尝试获取锁，如果失败了再排队。</p>
<p>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</p>
<h5 id="读写锁和排它锁"><a href="#读写锁和排它锁" class="headerlink" title="读写锁和排它锁"></a>读写锁和排它锁</h5><p>排它锁 ：同一时刻只允许一个线程进行访问 , synchronized用的锁和ReentrantLock，其实都是“排它锁”</p>
<p>读写锁 ： 可以再同一时刻允许多个读线程访问。<br>Java提供了 ReentrantReadWriteLock 类作为读写锁的默认实现，<br>内部维护了两个锁：一个读锁，一个写锁。<br>通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p>
<p>在写线程访问时，所有的读线程和其它写线程均被阻塞</p>
<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><p>JDK1.8 的StampedLock 的性能是非常优异的，基本上可以取代ReentrantReadWriteLock的作用。</p>
<h4 id="2-2-3-java-同步容器、线程安全的集合"><a href="#2-2-3-java-同步容器、线程安全的集合" class="headerlink" title="2.2.3 java 同步容器、线程安全的集合"></a>2.2.3 java 同步容器、线程安全的集合</h4><p>ConcurrentMap、阻塞队列（BlockingQueue）、CopyOnWrite容器（CopyOnWriteArrayList、 CopyOnWriteArraySet）</p>
<h5 id="concurrentHashMap-原理"><a href="#concurrentHashMap-原理" class="headerlink" title="concurrentHashMap 原理"></a>concurrentHashMap 原理</h5><p>ConcurrentMap接口继承了Map接口</p>
<p>ConcurrentHashMap同HashMap一样也是基于散列表的map</p>
<p>由 Hash值数组 + Node链表结构组成（链表也会在长度达到8的时候转化为红黑树）。<br>put数据时 以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，配合自旋+CAS避免不必要的锁开销，进一步提升并发性能。</p>
<p>采用了分段锁，将数据分段，对每一段数据分配一把锁。<br>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>有些方法需要跨段，比如 size()、isEmpty()、containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，<br>这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。</p>
<h5 id="ConcurrentHashMap-1-7和1-8的区别、jdk8对-ConcurrentHashMap-做了哪些优化"><a href="#ConcurrentHashMap-1-7和1-8的区别、jdk8对-ConcurrentHashMap-做了哪些优化" class="headerlink" title="ConcurrentHashMap 1.7和1.8的区别、jdk8对 ConcurrentHashMap 做了哪些优化"></a>ConcurrentHashMap 1.7和1.8的区别、jdk8对 ConcurrentHashMap 做了哪些优化</h5><ol>
<li><p>将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构， 避免链表过长</p>
</li>
<li><p>采用了分段锁，以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，<br>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
</li>
</ol>
<h5 id="concurrentHashMap-怎么实现线程安全，分段锁是jdk几提出的"><a href="#concurrentHashMap-怎么实现线程安全，分段锁是jdk几提出的" class="headerlink" title="concurrentHashMap 怎么实现线程安全，分段锁是jdk几提出的"></a>concurrentHashMap 怎么实现线程安全，分段锁是jdk几提出的</h5><p>JDK1.8提出分段锁，put时, synchronized 将Node链表的头节点作为锁，</p>
<p>在初始化数组时使用了 volatile + CAS + 自旋 操作 决定到底是哪个线程有资格进行初始化，其他线程均只能等待</p>
<h5 id="copyOnWrite原理"><a href="#copyOnWrite原理" class="headerlink" title="copyOnWrite原理"></a>copyOnWrite原理</h5><p>写时复制，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，<br>然后向新容器中添加我们需要的元素，<br>最后将原容器的引用指向新容器。</p>
<p>“读操作”是没有加锁，直接读取</p>
<p>适合读多写少的场景，缺点是复制原容器会占用两倍内存，不能保证实时一致性，只能保证最终一致性</p>
<h4 id="AtomicInteger-原子类的原理、AtomicInteger-怎么实现原子性"><a href="#AtomicInteger-原子类的原理、AtomicInteger-怎么实现原子性" class="headerlink" title="AtomicInteger 原子类的原理、AtomicInteger 怎么实现原子性"></a>AtomicInteger 原子类的原理、AtomicInteger 怎么实现原子性</h4><p>volatile 修改 int值， 底层通过 Unsafe类的 CAS操作尝试更新值</p>
<h4 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h4><h5 id="10-5-1-ABA问题"><a href="#10-5-1-ABA问题" class="headerlink" title="10.5.1 ABA问题"></a>10.5.1 ABA问题</h5><pre><code>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。

ABA问题的解决思路是在变量前面追加上版本号或者时间戳。      
从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。     </code></pre><h5 id="10-5-2-循环时间长开销大"><a href="#10-5-2-循环时间长开销大" class="headerlink" title="10.5.2 循环时间长开销大"></a>10.5.2 循环时间长开销大</h5><pre><code>CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。

解决思路是让JVM支持处理器提供的pause指令。

pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。      </code></pre><h5 id="10-5-3-只能保证一个共享变量的原子操作"><a href="#10-5-3-只能保证一个共享变量的原子操作" class="headerlink" title="10.5.3 只能保证一个共享变量的原子操作"></a>10.5.3 只能保证一个共享变量的原子操作</h5><pre><code>这个问题你可能已经知道怎么解决了。有两种解决方案：

使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；
使用 synchronize 锁。锁内的临界区代码可以保证只有当前线程能操作      </code></pre><hr>
<h2 id="3-Mysql"><a href="#3-Mysql" class="headerlink" title="3 Mysql"></a>3 Mysql</h2><h3 id="3-1-sql优化的思路"><a href="#3-1-sql优化的思路" class="headerlink" title="3.1 sql优化的思路"></a>3.1 sql优化的思路</h3><p>优化索引的使用，减少全表扫描，减少回表次数</p>
<ul>
<li>在 where条件字段，join 关联字段、order by 字段、建立索引</li>
<li>查询具体列名，不用select *</li>
<li>避免在查询列使用 函数</li>
<li>避免隐式转换</li>
<li>如果出现OR的一个条件没有索引时，建议使用 union 或建立联合索引</li>
</ul>
<h4 id="InnoDB有两大类索引："><a href="#InnoDB有两大类索引：" class="headerlink" title="InnoDB有两大类索引："></a>InnoDB有两大类索引：</h4><p>聚集索引(clustered index)</p>
<p>普通索引(secondary index)</p>
<h4 id="聚簇索引（clustered-index）与非聚簇索引（secondary-index）的区别-？"><a href="#聚簇索引（clustered-index）与非聚簇索引（secondary-index）的区别-？" class="headerlink" title="聚簇索引（clustered index）与非聚簇索引（secondary index）的区别 ？"></a>聚簇索引（clustered index）与非聚簇索引（secondary index）的区别 ？</h4><p>1、聚簇索引（clustered index)<br>a) 一个索引项直接对应实际数据记录的存储页，可谓“直达”，行数据就储存在索引树的叶子节点上<br>b) 主键缺省使用它<br>c) 索引项的排序和数据行的存储排序完全一致，利用这一点，想修改数据的存储顺序，可以通过改变主键的方法（撤销原有主键，另找也能满足主键要求的一个字段或一组字段，重建主键）<br>d) 一个表只能有一个聚簇索引（理由：数据一旦存储，顺序只能有一种）</p>
<p>2、非聚簇索引（secondary index）<br>a) 索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找<br>b) 一个表可以有多个非聚簇索引</p>
<h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>先定位主键值，再定位行记录，扫描两遍索引树，它的性能较扫一遍索引树更低。</p>
<h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p>
<p>常见的方法是：将被查询的字段，建立到联合索引里去。</p>
<h3 id="3-2-慢查询的处理方法、关注的字段（type、key、extra）"><a href="#3-2-慢查询的处理方法、关注的字段（type、key、extra）" class="headerlink" title="3.2 慢查询的处理方法、关注的字段（type、key、extra）"></a>3.2 慢查询的处理方法、关注的字段（type、key、extra）</h3><p>分析慢查询的执行计划，explain 查看 type 字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>
<p>key列显示索引实际决定使用的键，没有使用索引时 值为null</p>
<p>如果 Extra字段为 Using index condition ，可以通过建立联合索引，优化为 Using index</p>
<h3 id="3-3-事务隔离级别"><a href="#3-3-事务隔离级别" class="headerlink" title="3.3 事务隔离级别"></a>3.3 <a href="https://mp.weixin.qq.com/s/mZxAn7qRQ8EycVOcdql3hQ" target="_blank" rel="noopener">事务隔离级别</a></h3><h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h5><p>可能出现脏读（读取到其他事务未提交的数据）、</p>
<p>不能重复读： 在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）</p>
<p>幻读：在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除</p>
<h5 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h5><p>可能出现 幻读、不可重复读</p>
<h5 id="可重复读（mysql-innoDB-采用）"><a href="#可重复读（mysql-innoDB-采用）" class="headerlink" title="可重复读（mysql innoDB 采用）"></a>可重复读（mysql innoDB 采用）</h5><p>可能出现 幻读</p>
<h5 id="串行读"><a href="#串行读" class="headerlink" title="串行读"></a>串行读</h5><p>最严格的的隔离级别，并发效率低</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##### 脏读</span><br><span class="line">A事务读取到B事务未提交的数据</span><br><span class="line"></span><br><span class="line">##### 不可重复读 （行级锁可以处理这个问题）</span><br><span class="line">A事务内相同条件多次读取，由于B事务修改数据，导致多次读取结果值不一致</span><br><span class="line"></span><br><span class="line">##### 幻读 (表级锁可以处理这个问题)</span><br><span class="line">A事务内相同条件多次读取，由于B事务新增或者删除数据，导致多次读取结果总数不一致</span><br></pre></td></tr></table></figure>

<h4 id="3-4-sql-使用"><a href="#3-4-sql-使用" class="headerlink" title="3.4 sql 使用"></a>3.4 sql 使用</h4><h4 id="对于join-和-left-join-，-on-和where的结果有没有区别"><a href="#对于join-和-left-join-，-on-和where的结果有没有区别" class="headerlink" title="对于join 和 left join ， on 和where的结果有没有区别"></a>对于join 和 left join ， on 和where的结果有没有区别</h4><p>使用内连接（inner join / join）时没有区别  </p>
<h5 id="使用外连接（left-join-right-join）有区别"><a href="#使用外连接（left-join-right-join）有区别" class="headerlink" title="使用外连接（left join / right join）有区别"></a>使用外连接（left join / right join）有区别</h5><p>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。   </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    dep.dept_no</span><br><span class="line">    ,dep.emp_no</span><br><span class="line">    ,sal.salary</span><br><span class="line">    ,dep.from_date</span><br><span class="line">    ,dep.to_date</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    dept_manager dep</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> salaries sal</span><br><span class="line">    <span class="keyword">on</span> dep.emp_no = sal.emp_no</span><br><span class="line">    <span class="keyword">and</span> dep.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">and</span> sal.to_date = <span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure>

<p>where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正确栗子</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    dep.dept_no</span><br><span class="line">    ,dep.emp_no</span><br><span class="line">    ,sal.salary</span><br><span class="line">    ,dep.from_date</span><br><span class="line">    ,dep.to_date</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    dept_manager dep</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> salaries sal</span><br><span class="line">    <span class="keyword">on</span> dep.emp_no = sal.emp_no</span><br><span class="line"><span class="keyword">where</span>	</span><br><span class="line">    dep.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">and</span> sal.to_date = <span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-InnoDB与MyISAM对比"><a href="#3-5-InnoDB与MyISAM对比" class="headerlink" title="3.5 InnoDB与MyISAM对比"></a>3.5 InnoDB与MyISAM对比</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ceNmtYOhbMQs4Ar4C7lr5CFmTkzO5qFP4ziaEN8O2vgic8ibP9RnGibTDcVaAxTKfTxeicpCrYquzWXRstmdviaCrSzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></p>
<h3 id="innoDB怎么实现的ACID特性-、-Atomicity-原子性-Consistency-一致性-Isolation-隔离性-Transaction-持久性"><a href="#innoDB怎么实现的ACID特性-、-Atomicity-原子性-Consistency-一致性-Isolation-隔离性-Transaction-持久性" class="headerlink" title="innoDB怎么实现的ACID特性 、 Atomicity(原子性),Consistency(一致性),Isolation(隔离性),Transaction(持久性)"></a>innoDB怎么实现的ACID特性 、 Atomicity(原子性),Consistency(一致性),Isolation(隔离性),Transaction(持久性)</h3><p>通过事务控制，事务的本质就是锁和并发和重做日志的结合体</p>
<p>redo日志记录了数据变化的每一个动作，数据库锁保证了事务的隔离性，持有锁的事务才能修改数据</p>
<h3 id="innoDB支持几种锁"><a href="#innoDB支持几种锁" class="headerlink" title="innoDB支持几种锁"></a>innoDB支持几种锁</h3><p>一种是行级锁，一种是意向锁（表级别的锁）</p>
<ul>
<li>意向共享锁（读锁 IS Lock），事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>意向排他锁（写锁 IX Lock），事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ul>
<h3 id="innoDB的标准行级锁有哪两种"><a href="#innoDB的标准行级锁有哪两种" class="headerlink" title="innoDB的标准行级锁有哪两种"></a>innoDB的标准行级锁有哪两种</h3><p>共享锁（读锁 S Lock），允许事务读一行数据<br>排它锁（写锁 X Lock），允许事务删除一行数据或者更新一行数据</p>
<h3 id="B-树叶子节点存的是什么"><a href="#B-树叶子节点存的是什么" class="headerlink" title="B+树叶子节点存的是什么"></a>B+树叶子节点存的是什么</h3><p>主键KEY或者具体行数据</p>
<hr>
<h2 id="4-Spring"><a href="#4-Spring" class="headerlink" title="4 Spring"></a>4 Spring</h2><h3 id="spring-和-spring-boot的区别"><a href="#spring-和-spring-boot的区别" class="headerlink" title="spring 和 spring boot的区别"></a>spring 和 spring boot的区别</h3><ol>
<li><p>内嵌了如Tomcat，Jetty这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</p>
</li>
<li><p>无需再像Spring那样搞一堆繁琐的xml文件的配置</p>
</li>
<li><p>整合常用依赖，提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自动引入其他依赖</p>
</li>
</ol>
<h3 id="四种方式配置Bean"><a href="#四种方式配置Bean" class="headerlink" title="四种方式配置Bean"></a>四种方式配置Bean</h3><p>基于XML配置、注解配置、java类配置、Groovy DSL配置</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p><a href="https://www.jianshu.com/p/8bb67ca11831" target="_blank" rel="noopener">Spring 如何解决循环依赖的问题</a></p>
<p><a href="https://blog.csdn.net/hezuo1181/article/details/82831080" target="_blank" rel="noopener">面试官：spring循环依赖是怎么解决的？</a></p>
<h4 id="扫描注解定义的Bean"><a href="#扫描注解定义的Bean" class="headerlink" title="扫描注解定义的Bean"></a>扫描注解定义的Bean</h4><p>@Controller 、 @Service  、 @Repository 、@Component</p>
<h4 id="自动装配Bean"><a href="#自动装配Bean" class="headerlink" title="自动装配Bean"></a>自动装配Bean</h4><p>使用 @Autowired 默认按类型注入， 有多个相同类型时可以用 @Qualifier 指定Bean name</p>
<p>也可以使用 @Resource（按名称注入） 、 @Inject（按类型） </p>
<p>可以对类成员、方法标注 @Autowired，</p>
<p>@Order 指定相同类型的Bean的加载顺序，值越小越优先</p>
<h5 id="延迟依赖注入"><a href="#延迟依赖注入" class="headerlink" title="延迟依赖注入"></a>延迟依赖注入</h5><p>在class 和属性上同时标注 @lazy</p>
<h4 id="Bean的作用范围、生命过程"><a href="#Bean的作用范围、生命过程" class="headerlink" title="Bean的作用范围、生命过程"></a>Bean的作用范围、生命过程</h4><p>默认作用范围是 singleton 单例， 可以使用 @Scope(“prototype) 修改</p>
<p>在Bean实例化和属性注入完成后，执行 @PostConstruct 修饰的初始化方法</p>
<p>在容器关闭时，执行 @PreDestroy 修饰的方法</p>
<h4 id="基于Java-类的配置-Configuration"><a href="#基于Java-类的配置-Configuration" class="headerlink" title="基于Java 类的配置  @Configuration"></a>基于Java 类的配置  @Configuration</h4><p>@Configuration 本身标注了 @Component ，可以像普通Bean一样注入</p>
<p>普通的 POJO 只需要标注 @Configuration ，就可以为 Spring容器 提供bean定义<br>每个标注了 @Bean的类型方法 相当于提供了一个Bean的定义信息</p>
<p>Spring会对配置类标注了 @Bean的方法进行 Bean的实例化</p>
<h4 id="使用基于-Java类的配置信息-启动Spring容器"><a href="#使用基于-Java类的配置信息-启动Spring容器" class="headerlink" title="使用基于 Java类的配置信息 启动Spring容器"></a>使用基于 Java类的配置信息 启动Spring容器</h4><p>通过 AnnotationConfigApplicationContext 的 register() 方法，<br>然后调用 refresh() 方法</p>
<p>可以通过 @Import 注解 将多个配置类 组装到一个配置类</p>
<h3 id="通过编码方式动态添加-Bean"><a href="#通过编码方式动态添加-Bean" class="headerlink" title="通过编码方式动态添加 Bean"></a>通过编码方式动态添加 Bean</h3><h4 id="通过DefaultListableBeanFactory"><a href="#通过DefaultListableBeanFactory" class="headerlink" title="通过DefaultListableBeanFactory"></a>通过DefaultListableBeanFactory</h4><p> 动态注入Bean，使Bean被AOP增强， 需要实现BeanFactoryPostProcessor#postProcessBeanFactory()，</p>
<h3 id="AOP的原理、应用"><a href="#AOP的原理、应用" class="headerlink" title="AOP的原理、应用"></a>AOP的原理、应用</h3><p>动态代理，通过定义切面和增强，完成目标方法的增强       </p>
<ol>
<li><p>JDK动态代理，运行期完成，需要目标类实现接口，并且被拦截的方法在接口中有定义，通过反射生成接口的实现类，<br>生成快，运行效率低，适合非单例的Bean</p>
</li>
<li><p>cglib代理 ，运行期完成，动态创建子类，不能代理final、private方法，不需要目标类实现接口，生成慢，运行效率高，适合单例缓存池的Bean生成</p>
</li>
</ol>
<h3 id="Spring如何选择两种代理模式的？"><a href="#Spring如何选择两种代理模式的？" class="headerlink" title="Spring如何选择两种代理模式的？"></a>Spring如何选择两种代理模式的？</h3><pre><code>1、如果目标对象实现了接口，则默认采用JDK动态代理；

2、如果目标对象没有实现接口，则使用Cglib代理；

3、如果目标对象实现了接口，但强制使用了Cglib，则使用Cglib进行代理</code></pre><h4 id="4-2-Spring-事务"><a href="#4-2-Spring-事务" class="headerlink" title="4.2 Spring 事务"></a>4.2 Spring 事务</h4><p>事务模板类 TransactionTemplate 配合 事务回调 TransactionCallback 指定具体的持久化操作</p>
<p>TransactionDefinition：Spring支持的事务属性</p>
<p>TransactionStatus：代表事务具体运行状态</p>
<p>PlatformTransactionManager：事务管理抽象接口，提交、回滚；<br>不同的持久化框架有不同的实现类</p>
<p>重要的类 ： TransactionAspectSupport</p>
<h5 id="事务同步管理器"><a href="#事务同步管理器" class="headerlink" title="事务同步管理器"></a>事务同步管理器</h5><p>通过多个ThreadLocal变量保存线程不安全的事务相关的变量</p>
<h5 id="Spring事务的实现原理，嵌套事务的实现原理"><a href="#Spring事务的实现原理，嵌套事务的实现原理" class="headerlink" title="Spring事务的实现原理，嵌套事务的实现原理"></a>Spring事务的实现原理，嵌套事务的实现原理</h5><p>通过AOP实现， Spring将事务管理的步骤 织入业务方法的连接点，<br>比如获取线程绑定资源、开始事务、提交/回滚事务、异常处理</p>
<p>通过多个ThreadLocal变量保存线程不安全的事务相关的变量</p>
<p>设置保存点，可以回滚到保存点</p>
<h5 id="回滚设置"><a href="#回滚设置" class="headerlink" title="回滚设置"></a>回滚设置</h5><p>运行期异常引发回滚，检查型异常不会引发回滚</p>
<h5 id="Transaction-应用位置"><a href="#Transaction-应用位置" class="headerlink" title="@Transaction 应用位置"></a>@Transaction 应用位置</h5><p>在方法上使用时，方法上的配置会覆盖类上的配置</p>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><p>保存线程本地化的容器，<br>运行于多线程环境的某个对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本</p>
<h5 id="Spring事务的隔离级别？-默认值？"><a href="#Spring事务的隔离级别？-默认值？" class="headerlink" title="Spring事务的隔离级别？ 默认值？"></a>Spring事务的隔离级别？ 默认值？</h5><p>TransactionDefinition :<br>定义了与java.lang.sql同名的四个隔离级别，<br>还有一个 默认的隔离级别表示使用底层数据库的默认隔离级别</p>
<h5 id="Spring事务的传播属性？-默认值？"><a href="#Spring事务的传播属性？-默认值？" class="headerlink" title="Spring事务的传播属性？ 默认值？"></a>Spring事务的传播属性？ 默认值？</h5><p>默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Propagation propagation() default Propagation.REQUIRED;</span><br><span class="line">如果当前没有事务，新建一个事务，如果已经存在一个事务，加入到这个事务</span><br></pre></td></tr></table></figure>
<p>7种类型的事务传播行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_REQUIRED ：如果当前没有事务，新建一个事务，如果已经存在一个事务，加入到这个事务</span><br><span class="line"></span><br><span class="line">PROPAGATION_SUPPORTS ：如果当前有事务，加入这个事务，否则以非事务方式运行</span><br><span class="line"></span><br><span class="line">PROPAGATION_MANDATORY : 如果当前有事务，加入这个事务，否则抛出异常</span><br><span class="line"></span><br><span class="line">PROPAGATION_REQUIRES_NEW ： 新建事务，挂起当前事务</span><br><span class="line"></span><br><span class="line">PROPAGATION_NOT_SUPPORTED ：不允许事务，如果当前有事务，抛出异常</span><br><span class="line"></span><br><span class="line">PROPAGATION_NEVER ：如果当前没有事务，新建一个事务，如果已经存在一个事务，新建一个事务保存点</span><br><span class="line"></span><br><span class="line">PROPAGATION_NESTED： 使用嵌套事务时，底层数据源需要基于JDBC3.0，支持保存点</span><br></pre></td></tr></table></figure>


<h5 id="spring-事务不生效-Transactional注解无效-的场景"><a href="#spring-事务不生效-Transactional注解无效-的场景" class="headerlink" title="spring 事务不生效(@Transactional注解无效)的场景"></a>spring 事务不生效(@Transactional注解无效)的场景</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 如果不是Innodb存储引擎，MyISAM不支持事务。</span><br><span class="line"></span><br><span class="line">2. 没有指定rollbackFor参数默认只会捕获RuntimeException 和 Error 来进行回滚。</span><br><span class="line"></span><br><span class="line">3. 没有指定transactionManager参数，默认的transactionManager并不是我期望的，以及一个事务中涉及到了多个数据库。</span><br><span class="line"></span><br><span class="line">4. 如果AOP使用了JDK动态代理，对象内部方法互相调用不会被Spring的AOP拦截，另外代理 public static 方法无效（接口不能定义静态方法，而JDK动态代理是生成接口的子类）</span><br><span class="line"></span><br><span class="line">5. 如果AOP使用了CGLIB代理，事务方法或者类不是public（private static final），无法被外部包访问到，或者是final无法继承，@transactional注解无效</span><br></pre></td></tr></table></figure>

<h3 id="SpringBoot-自动装配的原理"><a href="#SpringBoot-自动装配的原理" class="headerlink" title="SpringBoot 自动装配的原理"></a>SpringBoot 自动装配的原理</h3><p>Spring Boot在启动的时候</p>
<ol>
<li>会将主配置类（即@SpringBootApplication标注的类）的所在包及子包里面所有组件扫描加载到Spring容器</li>
<li>会从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，<br>将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。<br>以前我们需要自己配置的东西，自动配置类都帮我们完成了</li>
</ol>
<h3 id="springboot的启动流程"><a href="#springboot的启动流程" class="headerlink" title="springboot的启动流程"></a>springboot的启动流程</h3><p>构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：</p>
<p>1.把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数。</p>
<p>2.判断是否是web程序，并设置到webEnvironment这个boolean属性中。 </p>
<p>3.找出所有的初始化器，默认有5个，设置到initializers属性中 。</p>
<p>4.找出所有的应用程序监听器，默认有9个，设置到listeners属性中 。</p>
<p>5.找出运行的主类(main class) 。</p>
<p>SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事：</p>
<p>1.构造一个StopWatch，观察SpringApplication的执行 。</p>
<p>2.找出所有的SpringApplicationRunListener并封装到SpringApplicationRunListeners中，用于监听run方法的执行。监听的过程中会封装成事件并广播出去让初始化过程中产生的应用程序监听器进行监听 。</p>
<p>3.构造Spring容器(ApplicationContext)，并返回 。</p>
<pre><code>3.1 创建Spring容器的判断是否是web环境，是的话构造AnnotationConfigEmbeddedWebApplicationContext，否则构造 AnnotationConfigApplicationContext 。

3.2 初始化过程中产生的初始化器在这个时候开始工作 。

3.3 Spring容器的刷新(完成bean的解析、各种processor接口的执行、条件注解的解析，aware接口的回调 等等) 。</code></pre><p>4.从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行。</p>
<hr>
<h2 id="5-Mybatis"><a href="#5-Mybatis" class="headerlink" title="5 Mybatis"></a>5 Mybatis</h2><h3 id="1-为什么要用-mybatis-这种持久层框架？"><a href="#1-为什么要用-mybatis-这种持久层框架？" class="headerlink" title="1. 为什么要用 mybatis 这种持久层框架？"></a>1. 为什么要用 mybatis 这种持久层框架？</h3><ol>
<li><p>原始的JDBC 访问数据库，没有用到数据库连接池，频繁创建销毁连接影响效率        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis 内部实现了 数据库连接池</span><br></pre></td></tr></table></figure>
</li>
<li><p>sql、配置文件耦合在代码里，不方便全局修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis 通过读取配置信息，赋值给 Configuration， </span><br><span class="line"></span><br><span class="line">全局单例配置对象 SqlSessionFactory 持有 Configuration</span><br></pre></td></tr></table></figure>
</li>
<li><p>消除了重复的模板代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 获取连接，参数替换</span><br><span class="line">2. 释放连接</span><br><span class="line">3. 处理异常</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-自己怎么实现mybatis，实现原理"><a href="#2-自己怎么实现mybatis，实现原理" class="headerlink" title="2. 自己怎么实现mybatis，实现原理"></a>2. 自己怎么实现mybatis，实现原理</h3><ol>
<li><p>获取数据库连接</p>
</li>
<li><p>获取sql，参数替换</p>
</li>
<li><p>执行sql，处理返回值</p>
</li>
</ol>
<h3 id="3-mybatis-一二级缓存配置"><a href="#3-mybatis-一二级缓存配置" class="headerlink" title="3. mybatis 一二级缓存配置"></a>3. mybatis 一二级缓存配置</h3><ol>
<li><p>默认开启，一级缓存是Session会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）；</p>
</li>
<li><p>二级缓存是 每一个Mapper都可以拥有一个Cache对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. 该select语句所在的Mapper，配置了&lt;cache&gt; 或&lt;cached-ref&gt;节点，并且有效</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>. 该select语句的参数 useCache=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="6-Rabbit-MQ"><a href="#6-Rabbit-MQ" class="headerlink" title="6 Rabbit MQ"></a>6 Rabbit MQ</h2><h3 id="Rabbit-MQ-架构设计"><a href="#Rabbit-MQ-架构设计" class="headerlink" title="Rabbit MQ 架构设计"></a>Rabbit MQ 架构设计</h3><p>生产者、信道（交换器、绑定、队列）、消费者</p>
<p>集群模式，至少一个磁盘节点</p>
<h3 id="如果-Rabbit-MQ-挂掉了，后续流程怎么处理"><a href="#如果-Rabbit-MQ-挂掉了，后续流程怎么处理" class="headerlink" title="如果 Rabbit MQ 挂掉了，后续流程怎么处理"></a>如果 Rabbit MQ 挂掉了，后续流程怎么处理</h3><p>搭建 Rabbit集群， Rabbit集群允许消费者和生产者在单个Rabbit MQ节点崩溃时 继续运行， </p>
<p>如果集群中唯一的磁盘节点崩溃的话，集群仍然可以保持运行，但是无法更改任何东西<br>可以在集群中设置多个磁盘节点</p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>如果消息要从 MQ重启后恢复，消息必须</p>
<ol>
<li>投递模式选项设置为2 （持久）</li>
<li>发送到持久化的交换器（durable 为 true）</li>
<li>达到持久化的队列（durable 为 true）</li>
</ol>
<p>MQ确保消息能从服务器重启中恢复的方式是 把消息写入磁盘上的一个持久化日志文件，<br>当发送一条持久化消息到交换器，Rabbit MQ 会在消息保存到日志文件后发送响应</p>
<p>Rabbit MQ 会在消费者消费后把持久化消息标记为等待垃圾回收</p>
<p>在消费之前，如果 Rabbit MQ重启，Rabbit MQ会重播日志文件中的消息到对应的队列 或者交换器</p>
<p>持久化消息到磁盘会影响吞吐效率</p>
<h3 id="Rabbit-MQ-如何保证消息正确投递"><a href="#Rabbit-MQ-如何保证消息正确投递" class="headerlink" title="Rabbit MQ 如何保证消息正确投递"></a>Rabbit MQ 如何保证消息正确投递</h3><h5 id="1、生产者丢数据"><a href="#1、生产者丢数据" class="headerlink" title="1、生产者丢数据"></a>1、生产者丢数据</h5><p>RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p>
<p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p>
<p>然而缺点就是吞吐量下降了，生产上用confirm模式的居多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)</span><br><span class="line"></span><br><span class="line">一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)</span><br><span class="line"></span><br><span class="line">这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</span><br><span class="line"></span><br><span class="line">相关接口 ：</span><br><span class="line">org.springframework.amqp.core.AmqpTemplate#convertSendAndReceive(java.lang.String, java.lang.String, java.lang.Object, org.springframework.amqp.core.MessagePostProcessor)</span><br></pre></td></tr></table></figure>

<h5 id="2、消息队列丢数据"><a href="#2、消息队列丢数据" class="headerlink" title="2、消息队列丢数据"></a>2、消息队列丢数据</h5><p>开启持久化磁盘的配置，在消息持久化磁盘后，再给生产者发送一个Ack信号。</p>
<p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>如何持久化呢，下面两步</p>
<p>1、将queue的持久化标识durable设置为true,则代表是一个持久的队列</p>
<p>2、发送消息的时候将deliveryMode=2</p>
<h5 id="3、消费者丢数据"><a href="#3、消费者丢数据" class="headerlink" title="3、消费者丢数据"></a>3、消费者丢数据</h5><p>消费者丢数据一般是因为采用了自动确认消息模式。</p>
<p>这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。</p>
<p>至于解决方案，==采用手动确认消息即可==  </p>
<h3 id="如何保证消息不被重复消费？"><a href="#如何保证消息不被重复消费？" class="headerlink" title="如何保证消息不被重复消费？"></a>如何保证消息不被重复消费？</h3><p>这个问题其实换一种问法就是，如何保证消息队列的幂等性?</p>
<p><strong>正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除</strong></p>
<p>RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念</p>
<h4 id="造成重复消费的原因"><a href="#造成重复消费的原因" class="headerlink" title="造成重复消费的原因?"></a>造成重复消费的原因?</h4><p> 就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者</p>
<h4 id="针对业务场景来答分以下几点"><a href="#针对业务场景来答分以下几点" class="headerlink" title="针对业务场景来答分以下几点"></a>针对业务场景来答分以下几点</h4><p>1、比如，你拿到这个消息做数据库的insert操作。</p>
<p>那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p>
<p>2、再比如，你拿到这个消息做redis的set的操作</p>
<p>那就容易了，不用解决。因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</p>
<p>3、如果上面两种情况还不行，上大招。</p>
<p>准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录 </p>
<h3 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h3><p>通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(rabbitMq中就是queue)。<br>然后只用一个消费者去消费该队列。</p>
<hr>
<h2 id="7-Redis"><a href="#7-Redis" class="headerlink" title="7 Redis"></a>7 Redis</h2><h3 id="为什么单线程更加快"><a href="#为什么单线程更加快" class="headerlink" title="为什么单线程更加快"></a>为什么单线程更加快</h3><ul>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU<ul>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作</li>
</ul>
</li>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li>
<li>数据结构简单，对数据操作也简单</li>
<li>使用多路I/O复用模型，非阻塞IO<ul>
<li>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，</li>
</ul>
</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p>
<p>Redis进行持久化的时候会以子进程或者子线程的方式执行        </p>
<h3 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h3><h4 id="快照模式（RDB）"><a href="#快照模式（RDB）" class="headerlink" title="快照模式（RDB）"></a>快照模式（RDB）</h4><p>在写操作不是特别频繁，允许丢失部分数据的场景下，<br>设置 每隔一段时间，达到一定写操作数量 ，进行自动保存，生成快照文件，或者进行手动保存</p>
<ul>
<li>save</li>
<li>bgsave ： fork子进程保存快照</li>
</ul>
<h4 id="AOF（Append-Only-File）-模式"><a href="#AOF（Append-Only-File）-模式" class="headerlink" title="AOF（Append Only File） 模式"></a>AOF（Append Only File） 模式</h4><p>同步写选项、同步频率</p>
<ul>
<li>always<br>  每个写命令都同步写入硬盘，会严重降低Redis 速度</li>
<li>everysec<br>  每秒执行一次同步，将多个写命令同步到硬盘</li>
<li>no<br>  让操作系统决定何时同步，不推荐</li>
</ul>
<h3 id="主从配置、哨兵模式，集群模式"><a href="#主从配置、哨兵模式，集群模式" class="headerlink" title="主从配置、哨兵模式，集群模式"></a>主从配置、哨兵模式，集群模式</h3><p>==只有主服务器接受写命令==</p>
<h4 id="更换故障主服务器"><a href="#更换故障主服务器" class="headerlink" title="更换故障主服务器"></a>更换故障主服务器</h4><h5 id="方法一：升级当前从服务器为主服务器"><a href="#方法一：升级当前从服务器为主服务器" class="headerlink" title="方法一：升级当前从服务器为主服务器"></a>方法一：升级当前从服务器为主服务器</h5><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><ol>
<li>复制从服务器数据到新的机器，</li>
<li>在新的机器上启动redis</li>
<li>为从服务器指定新的主服务器</li>
</ol>
<h4 id="redis集群是如何同步数据的？"><a href="#redis集群是如何同步数据的？" class="headerlink" title="redis集群是如何同步数据的？"></a>redis集群是如何同步数据的？</h4><h4 id="Redis复制过程"><a href="#Redis复制过程" class="headerlink" title="Redis复制过程"></a>Redis复制过程</h4><p>SLAVEOF host port 设置当前服务器为 某台服务器的从服务器</p>
<ol>
<li>从服务器连接主服务器，发送SYNC命令</li>
<li>主服务器执行 BGSAVE,在缓存区记录BGSAVE之后写入的命令，<br>从服务器会根据配置选择清空自身数据，或向客户端返回错误</li>
</ol>
<p>可以为从服务器指定新的从服务器，构成从服务器树</p>
<h4 id="哨兵模式-Redis-Sentinel"><a href="#哨兵模式-Redis-Sentinel" class="headerlink" title="哨兵模式 Redis Sentinel"></a>哨兵模式 Redis Sentinel</h4><p>目的是为了提供自动故障转移服务</p>
<p>配合Redis复制功能，Redis Sentinel是运行在特殊模式下的服务器<br>它会监视一系列主服务器和对应的从服务器，<br>==当主服务器失效时==，监视这个主服务器的所有Sentinel会基于彼此共有的信息选出一个新的主服务器，<br>其他的从服务器会去复制这个新的主服务器</p>
<h3 id="缓存雪崩和失效的场景"><a href="#缓存雪崩和失效的场景" class="headerlink" title="缓存雪崩和失效的场景"></a>缓存雪崩和失效的场景</h3><p>热点缓存key失效，大量请求直接访问数据库，导致数据库连接耗尽；</p>
<p>解决方案：</p>
<ul>
<li>查询前参数合理性校验</li>
<li>设置不同的过期时间</li>
<li>在查询数据库数据之前再查一遍redis（双重检查），查询数据库之后，新建redis缓存，设置过期时间 </li>
<li>应对大规模查询（应对秒杀活动），将查询放入消息队列</li>
</ul>
<hr>
<h2 id="8-SpringCloud-中间件"><a href="#8-SpringCloud-中间件" class="headerlink" title="8 SpringCloud 中间件"></a>8 SpringCloud 中间件</h2><h3 id="服务注册、服务发现-Eureka"><a href="#服务注册、服务发现-Eureka" class="headerlink" title="服务注册、服务发现 Eureka"></a>服务注册、服务发现 Eureka</h3><p>拉去Eureka服务端配置，并且不注册自身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: <span class="keyword">false</span></span><br><span class="line">    serviceUrl:</span><br><span class="line">      #      指定服务注册中心的地址</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8061/eureka/</span></span><br></pre></td></tr></table></figure>

<h3 id="Http客户端-Feign"><a href="#Http客户端-Feign" class="headerlink" title="Http客户端 Feign"></a>Http客户端 Feign</h3><h4 id="Feign设置超时时间"><a href="#Feign设置超时时间" class="headerlink" title="Feign设置超时时间"></a>Feign设置超时时间</h4><p>使用Feign调用接口分两层，ribbon的调用和hystrix的调用，所以ribbon的超时时间和Hystrix的超时时间的结合就是Feign的超时时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#hystrix的超时时间</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">              timeout:</span><br><span class="line">                enabled: <span class="keyword">true</span></span><br><span class="line">              isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                        timeoutInMilliseconds: <span class="number">9000</span></span><br><span class="line">#ribbon的超时时间</span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: <span class="number">3000</span></span><br><span class="line">  ConnectTimeout: <span class="number">3000</span></span><br><span class="line">  MaxAutoRetries: 1 #同一台实例最大重试次数,不包括首次调用</span><br><span class="line">  MaxAutoRetriesNextServer: 1 #重试负载均衡其他的实例最大重试次数,不包括首次调用</span><br><span class="line">  OkToRetryOnAllOperations: false  #是否所有操作都重试 </span><br><span class="line"></span><br><span class="line">一般情况下 都是 ribbon 的超时时间（&lt;）hystrix的超时时间（因为涉及到ribbon的重试机制）</span><br><span class="line">因为ribbon的重试机制和Feign的重试机制有冲突，所以源码中默认关闭Feign的重试机制</span><br><span class="line"></span><br><span class="line">hystrix超时时间的计算： (<span class="number">1</span> + MaxAutoRetries + MaxAutoRetriesNextServer) * ReadTimeout </span><br><span class="line"></span><br><span class="line">当ribbon超时后且hystrix没有超时，便会采取重试机制。当OkToRetryOnAllOperations设置为<span class="keyword">false</span>时，只会对get请求进行重试。如果设置为<span class="keyword">true</span>，便会对所有的请求进行重试，如果是put或post等写操作，如果服务器接口没做幂等性，会产生不好的结果，所以OkToRetryOnAllOperations慎用。</span><br><span class="line"></span><br><span class="line">如果不配置ribbon的重试次数，默认会重试一次        </span><br><span class="line">注意：     </span><br><span class="line">默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试</span><br><span class="line">非GET方式请求,只有连接异常时,才会进行重试</span><br></pre></td></tr></table></figure>


<h3 id="负载均衡-ribbon、"><a href="#负载均衡-ribbon、" class="headerlink" title="负载均衡 ribbon、"></a>负载均衡 ribbon、</h3><h3 id="服务降级-Hystrix"><a href="#服务降级-Hystrix" class="headerlink" title="服务降级 Hystrix"></a>服务降级 Hystrix</h3><hr>
<h2 id="9-Zookeeper"><a href="#9-Zookeeper" class="headerlink" title="9 Zookeeper"></a>9 Zookeeper</h2><p>主节点失效，备份主节点需要通过选举，成为新的主节点，<br>如果旧的主节点恢复，==如何避免存在两个主节点（脑裂）==</p>
<p>从节点如果失效，主节点应该能够检测到，不在继续派发任务给失效节点，<br>重新派发未完成任务给其他节点，==如何避免重复消费==</p>
<p>主从节点 保持通信</p>
<h4 id="几个重要的-父znode"><a href="#几个重要的-父znode" class="headerlink" title="几个重要的 父znode"></a>几个重要的 父znode</h4><p>/workers  /assign     /tasks</p>
<h3 id="zookeeper-实现分布式锁"><a href="#zookeeper-实现分布式锁" class="headerlink" title="zookeeper 实现分布式锁"></a>zookeeper 实现分布式锁</h3><p>一个线程尝试创建 临时节点 /lock, (临时节点会在会话过期 或关闭时 自动被删除) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e &#x2F;lock &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>其他线程因为节点存在，无法创建/lock<br>监听到 /lock 删除时，再次尝试创建 /lock，如果其他线程创建 /lock 成功，继续监听 /lock</p>
<h4 id="在主节点上增加监视点"><a href="#在主节点上增加监视点" class="headerlink" title="在主节点上增加监视点"></a>在主节点上增加监视点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat &#x2F;master true</span><br></pre></td></tr></table></figure>

<h4 id="设置-子节点的监视点"><a href="#设置-子节点的监视点" class="headerlink" title="设置 子节点的监视点"></a>设置 子节点的监视点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;workers true</span><br></pre></td></tr></table></figure>

<h4 id="Zookeeper一致性协议原理Zab-，ZAB（ZooKeeper-Atomic-Broadcast-）-全称为：原子消息广播协议"><a href="#Zookeeper一致性协议原理Zab-，ZAB（ZooKeeper-Atomic-Broadcast-）-全称为：原子消息广播协议" class="headerlink" title="Zookeeper一致性协议原理Zab ，ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议"></a>Zookeeper一致性协议原理Zab ，ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议</h4><p>ZAB可以说是在Paxos算法基础上进行了扩展改造而来的，ZAB协议设计了支持崩溃恢复</p>
<p>ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求，采用ZAB协议将服务器数状态 以事务形式 广播到所有Follower上；</p>
<h5 id="ZAB协议的两个基本模式：恢复模式和广播模式"><a href="#ZAB协议的两个基本模式：恢复模式和广播模式" class="headerlink" title="ZAB协议的两个基本模式：恢复模式和广播模式"></a>ZAB协议的两个基本模式：恢复模式和广播模式</h5><p>恢复模式:（选举）<br>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了</p>
<p>广播模式：（数据同步）<br>ZooKeeper服务一直维持在广播状态，直到Leader崩溃了或者Leader失去了大部分的Followers支持。</p>
<p>广播模式极其类似于分布式事务中的2pc（two-phrase commit 两阶段提交）：<br>即Leader提起一个决议，由Followers进行投票，Leader对投票结果进行计算决定是否通过该决议，如果通过执行该决议（事务），否则什么也不做</p>
<hr>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="用过的设计模式有哪些"><a href="#用过的设计模式有哪些" class="headerlink" title="用过的设计模式有哪些"></a>用过的设计模式有哪些</h3><h2 id="10-性能优化"><a href="#10-性能优化" class="headerlink" title="10 性能优化"></a>10 性能优化</h2><h3 id="线上oom怎么排查-1"><a href="#线上oom怎么排查-1" class="headerlink" title="线上oom怎么排查"></a>线上oom怎么排查</h3><p>查看日志、分析dump文件，查看占用内存较多的对象</p>
<ol>
<li><p>ps -aux|grep java 当服务重新部署后，可以找出当前Java进程的PID</p>
</li>
<li><p>jstat -gcutil pid interval 用于查看当前GC的状态,它对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控</p>
</li>
<li><p>jmap -histo:live pid 可用统计存活对象的分布情况，从高到低查看占据内存最多的对象。上图</p>
</li>
<li><p>分析dump文件</p>
</li>
</ol>
<h4 id="如果一个-前端请求查询耗时很长，怎么优化"><a href="#如果一个-前端请求查询耗时很长，怎么优化" class="headerlink" title="如果一个 前端请求查询耗时很长，怎么优化"></a>如果一个 前端请求查询耗时很长，怎么优化</h4><ul>
<li>查看nginx日志，是否是网络问题</li>
<li>top命令查看 服务器内存 、IO情况，</li>
<li>查看服务日志，是否代码逻辑不合理，是否有多线程锁竞争</li>
<li>开启慢查询，是否有较慢的sql，能否优化查询，优化索引</li>
<li>热点数据是够可以缓存<br><img src="https://img-blog.csdnimg.cn/20190111141308700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdhZGFt,size_16,color_FFFFFF,t_70" alt="image"></li>
<li>第三方接口调用超时</li>
</ul>
<ul>
<li><p>线上内存溢出的场景和处理方法</p>
<ul>
<li>top定位查看服务器状态，获取占用内存多的进程ID，保存线程栈信息，</li>
<li>下载dump文件，分析 dump文件</li>
</ul>
</li>
<li><p>zookeeper / eureka 配置本地调用公共服务</p>
</li>
</ul>
<h4 id="nginx中的超时设置，请求超时、响应等待超时等"><a href="#nginx中的超时设置，请求超时、响应等待超时等" class="headerlink" title="nginx中的超时设置，请求超时、响应等待超时等"></a><a href="https://blog.csdn.net/qq_29663071/article/details/81061420" target="_blank" rel="noopener">nginx中的超时设置，请求超时、响应等待超时等</a></h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="从1000w个数字中找出最小的10个并打印"><a href="#从1000w个数字中找出最小的10个并打印" class="headerlink" title="从1000w个数字中找出最小的10个并打印"></a>从1000w个数字中找出最小的10个并打印</h4><p>advance.sort.HeapSort.findMinTopK</p>
<hr>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485070&idx=1&sn=31894a1bdda357d897962a9fc3a994b7&chksm=cea24945f9d5c0531db568321f1d8d7a4e848e04aa2df18e589db9ba4aafee0fb0cebb965252&token=463285003&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">记一次蚂蚁金服的面试经历</a></li>
</ul>
<p><a href="https://www.bilibili.com/read/cv5554230?share_medium=android&amp;share_source=weixin&amp;bbid=87E1A2EB-DC6F-4726-A9A5-51D5A927762310277infoc&amp;ts=1586753871769" target="_blank" rel="noopener">https://www.bilibili.com/read/cv5554230?share_medium=android&amp;share_source=weixin&amp;bbid=87E1A2EB-DC6F-4726-A9A5-51D5A927762310277infoc&amp;ts=1586753871769</a></p>


            
            
            <blockquote>
                <p>
                本文地址：
                <a href="http://yoursite.com/2020/05/23/interview-10-8-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" target="_blank" rel="external">http://yoursite.com/2020/05/23/interview-10-8-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</a>
                </p>
                <footer><cite><a href="http://yoursite.com">@Pirate5946</a></cite></footer>
            </blockquote>
            </div>
            
<nav class="post-nav">
  
    <div class="waves-block waves-effect prev fl">
      <a href="/2020/05/23/princple-2018-02-06-TODO/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">princple-2018-02-06-TODO</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next fr">
      <a href="/2020/05/23/youdao-notes-2017-10-20-%E4%B9%A6%E5%8D%95%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">书单,笔记,学习资源整理</h4>
      </a>
    </div>
  
</nav>


            
            
<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="interview-10-8-高频面试题整理" data-title="面试整理" data-url="http://yoursite.com/2020/05/23/interview-10-8-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"ysblog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





        </div>
    </div>
</article>

    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "面试整理",
    pic: "/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://yoursite.com/2020/05/23/interview-10-8-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>


<script src="/js/main.js"></script>




<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>


<script src="/js/search.js"></script>










</body>
</html>
